--- a/net/minecraft/world/chunk/NibbleArray.java
+++ b/net/minecraft/world/chunk/NibbleArray.java
@@ -1,9 +_,71 @@
 package net.minecraft.world.chunk;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import com.destroystokyo.paper.util.MCUtil;
+import com.destroystokyo.paper.util.pooled.PooledObjects;
 import net.minecraft.util.Util;
 
 public class NibbleArray {
+
+   public static final NibbleArray EMPTY_NIBBLE_ARRAY = new NibbleArray() {
+      @Override
+      public byte[] func_177481_a() {
+         throw new IllegalStateException();
+      }
+   };
+
+   public long lightCacheKey = Long.MIN_VALUE;
+   public static byte[] EMPTY_NIBBLE = new byte[2048];
+   private static final int nibbleBucketSizeMultiplier = Integer.getInteger("Paper.nibbleBucketSize", 3072);
+   private static final int maxPoolSize = Integer.getInteger("Paper.maxNibblePoolSize", (int) Math.min(6, Math.max(1, Runtime.getRuntime().maxMemory() / 1024 / 1024 / 1024)) * (nibbleBucketSizeMultiplier * 8));
+   public static final PooledObjects<byte[]> BYTE_2048 = new PooledObjects<>(() -> new byte[2048], maxPoolSize);
+   public static void releaseBytes(byte[] bytes) {
+      if (bytes != null && bytes != EMPTY_NIBBLE && bytes.length == 2048) {
+         System.arraycopy(EMPTY_NIBBLE, 0, bytes, 0, 2048);
+         BYTE_2048.release(bytes);
+      }
+   }
+
+   public NibbleArray markPoolSafe(byte[] bytes) {
+      if (bytes != EMPTY_NIBBLE) this.field_76585_a = bytes;
+      return markPoolSafe();
+   }
+   public NibbleArray markPoolSafe() {
+      poolSafe = true;
+      return this;
+   }
+   public byte[] getIfSet() {
+      return this.field_76585_a != null ? this.field_76585_a : EMPTY_NIBBLE;
+   }
+   public byte[] getCloneIfSet() {
+      if (field_76585_a == null) {
+         return EMPTY_NIBBLE;
+      }
+      byte[] ret = BYTE_2048.acquire();
+      System.arraycopy(getIfSet(), 0, ret, 0, 2048);
+      return ret;
+   }
+
+   public NibbleArray cloneAndSet(byte[] bytes) {
+      if (bytes != null && bytes != EMPTY_NIBBLE) {
+         this.field_76585_a = BYTE_2048.acquire();
+         System.arraycopy(bytes, 0, this.field_76585_a, 0, 2048);
+      }
+      return this;
+   }
+   boolean poolSafe = false;
+   public java.lang.Runnable cleaner;
+   private void registerCleaner() {
+      if (!poolSafe) {
+         cleaner = MCUtil.registerCleaner(this, this.field_76585_a, NibbleArray::releaseBytes);
+      } else {
+         cleaner = MCUtil.once(() -> NibbleArray.releaseBytes(this.field_76585_a));
+      }
+   }
+   // Paper end
+
    @Nullable
    protected byte[] field_76585_a;
 
@@ -11,9 +_,20 @@
    }
 
    public NibbleArray(byte[] p_i45646_1_) {
-      this.field_76585_a = p_i45646_1_;
-      if (p_i45646_1_.length != 2048) {
-         throw (IllegalArgumentException)Util.func_229757_c_(new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + p_i45646_1_.length));
+      this(p_i45646_1_, false);
+//      this.data = p_i45646_1_;
+//      if (p_i45646_1_.length != 2048) {
+//         throw (IllegalArgumentException)Util.pauseInIde(new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + p_i45646_1_.length));
+//      }
+   }
+
+   public NibbleArray(byte[] abyte, boolean isSafe) {
+      this.field_76585_a = abyte;
+      if (!isSafe) this.field_76585_a = getCloneIfSet(); // Paper - clone for safety
+      registerCleaner();
+      // Paper end
+      if (abyte.length != 2048) {
+         throw (IllegalArgumentException) Util.func_229757_c_((Throwable) (new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + abyte.length)));
       }
    }
 
@@ -44,16 +_,18 @@
 
    private void func_177482_a(int p_177482_1_, int p_177482_2_) {
       if (this.field_76585_a == null) {
-         this.field_76585_a = new byte[2048];
+         this.field_76585_a = BYTE_2048.acquire();
+         registerCleaner();
       }
 
       int i = this.func_177478_c(p_177482_1_);
+
+
       if (this.func_177479_b(p_177482_1_)) {
          this.field_76585_a[i] = (byte)(this.field_76585_a[i] & 240 | p_177482_2_ & 15);
       } else {
          this.field_76585_a[i] = (byte)(this.field_76585_a[i] & 15 | (p_177482_2_ & 15) << 4);
       }
-
    }
 
    private boolean func_177479_b(int p_177479_1_) {
@@ -67,13 +_,35 @@
    public byte[] func_177481_a() {
       if (this.field_76585_a == null) {
          this.field_76585_a = new byte[2048];
-      }
-
-      return this.field_76585_a;
-   }
+      } else { // Paper start
+         // Accessor may need this object past garbage collection so need to clone it and return pooled value
+         // If we know its safe for pre GC access, use asBytesPoolSafe(). If you just need read, use getIfSet()
+         Runnable cleaner = this.cleaner;
+         if (cleaner != null) {
+            this.field_76585_a = this.field_76585_a.clone();
+            cleaner.run(); // release the previously pooled value
+            this.cleaner = null;
+         }
+      }
+      // Paper end
+
+      return this.field_76585_a;
+   }
+
+   @Nonnull
+   public byte[] asBytesPoolSafe() {
+      if (this.field_76585_a == null) {
+         this.field_76585_a = BYTE_2048.acquire(); // Paper
+         registerCleaner(); // Paper
+      }
+
+      //noinspection ConstantConditions
+      return this.field_76585_a;
+   }
+   // Paper end
 
    public NibbleArray func_215654_b() {
-      return this.field_76585_a == null ? new NibbleArray() : new NibbleArray((byte[])this.field_76585_a.clone());
+      return this.field_76585_a == null ? new NibbleArray() : new NibbleArray((byte[])this.field_76585_a);
    }
 
    public String toString() {
