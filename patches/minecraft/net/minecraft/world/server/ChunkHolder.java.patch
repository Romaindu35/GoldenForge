--- a/net/minecraft/world/server/ChunkHolder.java
+++ b/net/minecraft/world/server/ChunkHolder.java
@@ -18,6 +_,7 @@
 import net.minecraft.network.play.server.SMultiBlockChangePacket;
 import net.minecraft.network.play.server.SUpdateLightPacket;
 import net.minecraft.network.play.server.SUpdateTileEntityPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.Util;
 import net.minecraft.util.math.BlockPos;
@@ -44,9 +_,9 @@
    private static final List<ChunkStatus> field_219310_e = ChunkStatus.func_222582_a();
    private static final ChunkHolder.LocationType[] field_219311_f = ChunkHolder.LocationType.values();
    private final AtomicReferenceArray<CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>>> field_219312_g = new AtomicReferenceArray<>(field_219310_e.size());
-   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_222983_h = field_219309_d;
-   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219313_h = field_219309_d;
-   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219314_i = field_219309_d;
+   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_222983_h = field_219309_d; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
+   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219313_h = field_219309_d; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
+   private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219314_i = field_219309_d; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
    private CompletableFuture<IChunk> field_219315_j = CompletableFuture.completedFuture((IChunk)null);
    private int field_219316_k;
    private int field_219317_l;
@@ -62,6 +_,20 @@
    private boolean field_219329_x;
    private boolean field_244384_x;
 
+   // GoldenForge start
+   public final boolean isEntityTickingReady() {
+      return this.isEntityTickingReady;
+   }
+
+   public final boolean isTickingReady() {
+      return this.isTickingReady;
+   }
+
+   public final boolean isFullChunkReady() {
+      return this.isFullChunkReady;
+   }
+   // GoldenForge end
+
    public ChunkHolder(ChunkPos p_i50716_1_, int p_i50716_2_, WorldLightManager p_i50716_3_, ChunkHolder.IListener p_i50716_4_, ChunkHolder.IPlayerProvider p_i50716_5_) {
       this.field_219319_n = p_i50716_1_;
       this.field_219326_u = p_i50716_3_;
@@ -204,7 +_,7 @@
    }
 
    private void func_244385_a(World p_244385_1_, BlockPos p_244385_2_, BlockState p_244385_3_) {
-      if (p_244385_3_.func_177230_c().func_235695_q_()) {
+      if (p_244385_3_.hasTileEntity()) {
          this.func_219305_a(p_244385_1_, p_244385_2_);
       }
 
@@ -282,6 +_,7 @@
       this.field_219317_l = p_219292_1_;
    }
 
+   protected long updateCount; // Tuinity - correctly handle recursion
    protected void func_219291_a(ChunkManager p_219291_1_) {
       ChunkStatus chunkstatus = func_219278_b(this.field_219316_k);
       ChunkStatus chunkstatus1 = func_219278_b(this.field_219317_l);
@@ -289,6 +_,40 @@
       boolean flag1 = this.field_219317_l <= ChunkManager.field_219249_a;
       ChunkHolder.LocationType chunkholder$locationtype = func_219286_c(this.field_219316_k);
       ChunkHolder.LocationType chunkholder$locationtype1 = func_219286_c(this.field_219317_l);
+
+      // CraftBukkit start
+      // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
+      if (chunkholder$locationtype.func_219065_a(ChunkHolder.LocationType.BORDER) && !chunkholder$locationtype1.func_219065_a(ChunkHolder.LocationType.BORDER)) {
+         this.func_219301_a(ChunkStatus.field_222617_m).thenAccept((either) -> { // Paper - ensure main // Tuinity - is always on main
+            Chunk chunk = (Chunk)either.left().orElse(null);
+            if (chunk != null) {
+               p_219291_1_.callbackExecutor.execute(() -> {
+                  // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
+                  // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
+                  // These actions may however happen deferred, so we manually set the needsSaving flag already here.
+                  chunk.func_177427_f(true);
+                  chunk.unloadCallback();
+               });
+            }
+         }).exceptionally((throwable) -> {
+            // ensure exceptions are printed, by default this is not the case
+            MinecraftServer.field_147145_h.fatal("Failed to schedule unload callback for chunk " + ChunkHolder.this.field_219319_n, throwable);
+            return null;
+         });
+
+         // Run callback right away if the future was already done
+         p_219291_1_.callbackExecutor.run();
+         // Tuinity start - correctly handle recursion
+         if (this.updateCount != updateCount) {
+            // something else updated ticket level for us.
+            return;
+         }
+         // Tuinity end - correctly handle recursion
+      }
+      // CraftBukkit end
+
+      CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture;
+
       if (flag) {
          Either<IChunk, ChunkHolder.IChunkLoadingError> either = Either.right(new ChunkHolder.IChunkLoadingError() {
             public String toString() {
@@ -297,7 +_,7 @@
          });
 
          for(int i = flag1 ? chunkstatus1.func_222584_c() + 1 : 0; i <= chunkstatus.func_222584_c(); ++i) {
-            CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.field_219312_g.get(i);
+            completablefuture = this.field_219312_g.get(i);
             if (completablefuture != null) {
                completablefuture.complete(either);
             } else {
@@ -310,13 +_,29 @@
       boolean flag6 = chunkholder$locationtype1.func_219065_a(ChunkHolder.LocationType.BORDER);
       this.field_219329_x |= flag6;
       if (!flag5 && flag6) {
-         this.field_222983_h = p_219291_1_.func_222961_b(this);
+         // Paper start - cache ticking ready status
+         int expectCreateCount = ++this.fullChunkCreateCount;
+         this.field_222983_h = p_219291_1_.func_222961_b(this); this.field_222983_h.thenAccept((either) -> { // Paper - ensure main // Tuinity - always fired on main
+            com.tuinity.tuinity.util.TickThread.ensureTickThread("Async full chunk future completion"); // Tuinity
+            if (either.left().isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
+               // note: Here is a very good place to add callbacks to logic waiting on this.
+               Chunk fullChunk = either.left().get();
+               ChunkHolder.this.isFullChunkReady = true;
+               //fullChunk.playerChunk = PlayerChunk.this;
+               //this.chunkMap.chunkDistanceManager.clearPriorityTickets(location);
+
+
+            }
+         });
+         // Paper end
          this.func_219284_a(this.field_222983_h);
       }
 
       if (flag5 && !flag6) {
          CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture1 = this.field_222983_h;
          this.field_222983_h = field_219309_d;
+         ++this.fullChunkCreateCount; // Paper - cache ticking ready status
+         this.isFullChunkReady = false; // Paper - cache ticking ready status
          this.func_219284_a(completablefuture1.thenApply((p_222982_1_) -> {
             return p_222982_1_.ifLeft(p_219291_1_::func_222973_a);
          }));
@@ -325,12 +_,26 @@
       boolean flag7 = chunkholder$locationtype.func_219065_a(ChunkHolder.LocationType.TICKING);
       boolean flag2 = chunkholder$locationtype1.func_219065_a(ChunkHolder.LocationType.TICKING);
       if (!flag7 && flag2) {
-         this.field_219313_h = p_219291_1_.func_219179_a(this);
+         this.field_219313_h = p_219291_1_.func_219179_a(this); this.field_219313_h.thenAccept((either) -> { // Paper - ensure main // Tuinity - always completed on main
+            com.tuinity.tuinity.util.TickThread.ensureTickThread("Async ticking chunk future completion"); // Tuinity
+            if (either.left().isPresent()) {
+               // note: Here is a very good place to add callbacks to logic waiting on this.
+               Chunk tickingChunk = either.left().get();
+               ChunkHolder.this.isTickingReady = true;
+
+
+               // Paper start - rewrite ticklistserver
+               p_219291_1_.field_219255_i.onChunkSetTicking(ChunkHolder.this.field_219319_n.field_77276_a, ChunkHolder.this.field_219319_n.field_77275_b);
+               // Paper end - rewrite ticklistserver
+
+            }
+         });
+         // Paper end
          this.func_219284_a(this.field_219313_h);
       }
 
       if (flag7 && !flag2) {
-         this.field_219313_h.complete(field_219308_c);
+         this.field_219313_h.complete(field_219308_c); this.isTickingReady = false; // Paper - cache chunk ticking stage
          this.field_219313_h = field_219309_d;
       }
 
@@ -341,17 +_,47 @@
             throw (IllegalStateException)Util.func_229757_c_(new IllegalStateException());
          }
 
-         this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n);
+         this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n); this.field_219314_i.thenAccept((either) -> { // Paper ensureMain // Tuinity - always completed on main
+            com.tuinity.tuinity.util.TickThread.ensureTickThread("Async entity ticking chunk future completion"); // Tuinity
+            if (either.left().isPresent()) {
+               // note: Here is a very good place to add callbacks to logic waiting on this.
+               Chunk entityTickingChunk = either.left().get();
+               ChunkHolder.this.isEntityTickingReady = true;
+
+
+            }
+         });
+         // Paper end
          this.func_219284_a(this.field_219314_i);
       }
 
       if (flag3 && !flag4) {
-         this.field_219314_i.complete(field_219308_c);
+         this.field_219314_i.complete(field_219308_c);  this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
          this.field_219314_i = field_219309_d;
       }
 
       this.field_219327_v.func_219066_a(this.field_219319_n, this::func_219281_j, this.field_219317_l, this::func_219275_d);
       this.field_219316_k = this.field_219317_l;
+      // CraftBukkit start
+      // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
+      if (!chunkholder$locationtype.func_219065_a(ChunkHolder.LocationType.BORDER) && chunkholder$locationtype1.func_219065_a(ChunkHolder.LocationType.BORDER)) {
+         this.func_219301_a(ChunkStatus.field_222617_m).thenAccept((either) -> { // Paper - ensure main // Tuinity - is always on main
+            Chunk chunk = (Chunk)either.left().orElse(null);
+            if (chunk != null) {
+               p_219291_1_.callbackExecutor.execute(() -> {
+                  chunk.loadCallback();
+               });
+            }
+         }).exceptionally((throwable) -> {
+            // ensure exceptions are printed, by default this is not the case
+            MinecraftServer.field_147145_h.fatal("Failed to schedule load callback for chunk " + ChunkHolder.this.field_219319_n, throwable);
+            return null;
+         });
+
+         // Run callback right away if the future was already done
+         p_219291_1_.callbackExecutor.run();
+      }
+      // CraftBukkit end
    }
 
    public static ChunkStatus func_219278_b(int p_219278_0_) {
