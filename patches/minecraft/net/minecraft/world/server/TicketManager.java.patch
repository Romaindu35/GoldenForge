--- a/net/minecraft/world/server/TicketManager.java
+++ b/net/minecraft/world/server/TicketManager.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.server;
 
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
@@ -22,8 +_,10 @@
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.ServerPlayerEntity;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.concurrent.ITaskExecutor;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.SectionPos;
 import net.minecraft.world.chunk.Chunk;
@@ -32,6 +_,7 @@
 import net.minecraft.world.chunk.ChunkTaskPriorityQueueSorter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class TicketManager {
    private static final Logger field_219373_a = LogManager.getLogger();
@@ -39,9 +_,20 @@
    private final Long2ObjectMap<ObjectSet<ServerPlayerEntity>> field_219375_c = new Long2ObjectOpenHashMap<>();
    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> field_219377_e = new Long2ObjectOpenHashMap<>();
    private final TicketManager.ChunkTicketTracker field_219378_f = new TicketManager.ChunkTicketTracker();
-   private final TicketManager.PlayerChunkTracker field_219381_i = new TicketManager.PlayerChunkTracker(8);
+   public static final int MOB_SPAWN_RANGE = 8;
+   //private final TicketManager.PlayerChunkTracker naturalSpawnChunkCounter = new TicketManager.PlayerChunkTracker(8);
    private final TicketManager.PlayerTicketTracker field_219382_j = new TicketManager.PlayerTicketTracker(33);
-   private final Set<ChunkHolder> field_219383_k = Sets.newHashSet();
+   //private final Set<ChunkHolder> chunksToUpdateFutures = Sets.newHashSet();
+   // Paper start use a queue, but still keep unique requirement
+   public final java.util.Queue<ChunkHolder> field_219383_k = new java.util.ArrayDeque<ChunkHolder>() {
+      @Override
+      public boolean add(ChunkHolder o) {
+         if (o.isUpdateQueued) return true;
+         o.isUpdateQueued = true;
+         return super.add(o);
+      }
+   };
+   // Paper end
    private final ChunkTaskPriorityQueueSorter field_219384_l;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219385_m;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.RunnableEntry> field_219386_n;
@@ -49,6 +_,12 @@
    private final Executor field_219388_p;
    private long field_219389_q;
 
+   private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> forcedTickets = new Long2ObjectOpenHashMap<>();
+
+   ChunkManager chunkMap; // Paper
+
+
+
    protected TicketManager(Executor p_i50707_1_, Executor p_i50707_2_) {
       ITaskExecutor<Runnable> itaskexecutor = ITaskExecutor.func_213140_a("player ticket throttler", p_i50707_2_::execute);
       ChunkTaskPriorityQueueSorter chunktaskpriorityqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(itaskexecutor), p_i50707_1_, 4);
@@ -78,6 +_,7 @@
    }
 
    private static int func_229844_a_(SortedArraySet<Ticket<?>> p_229844_0_) {
+      AsyncCatcher.catchOp("ChunkMapDistance::getLowestTicketLevel"); // Paper
       return !p_229844_0_.isEmpty() ? p_229844_0_.func_226178_b_().func_219477_b() : ChunkManager.field_219249_a + 1;
    }
 
@@ -90,18 +_,30 @@
    protected abstract ChunkHolder func_219372_a(long p_219372_1_, int p_219372_3_, @Nullable ChunkHolder p_219372_4_, int p_219372_5_);
 
    public boolean func_219353_a(ChunkManager p_219353_1_) {
-      this.field_219381_i.func_215497_a();
+      AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
+      //this.naturalSpawnChunkCounter.runAllUpdates();
       this.field_219382_j.func_215497_a();
       int i = Integer.MAX_VALUE - this.field_219378_f.func_215493_a(Integer.MAX_VALUE);
       boolean flag = i != 0;
       if (flag) {
       }
 
+//      if (!this.chunksToUpdateFutures.isEmpty()) {
+//         this.chunksToUpdateFutures.forEach((p_219343_1_) -> {
+//            p_219343_1_.updateFutures(p_219353_1_);
+//         });
+//         this.chunksToUpdateFutures.clear();
+//         return true;
+      // Paper start
       if (!this.field_219383_k.isEmpty()) {
-         this.field_219383_k.forEach((p_219343_1_) -> {
-            p_219343_1_.func_219291_a(p_219353_1_);
-         });
-         this.field_219383_k.clear();
+         this.pollingPendingChunkUpdates = true; try {
+            while(!this.field_219383_k.isEmpty()) {
+               ChunkHolder remove = this.field_219383_k.remove();
+               remove.isUpdateQueued = false;
+               remove.func_219291_a(p_219353_1_);
+            }
+         } finally { this.pollingPendingChunkUpdates = false; }
+         // Paper end
          return true;
       } else {
          if (!this.field_219387_o.isEmpty()) {
@@ -134,7 +_,10 @@
       }
    }
 
-   private void func_219347_a(long p_219347_1_, Ticket<?> p_219347_3_) {
+   public boolean pollingPendingChunkUpdates = false; // Paper
+
+
+   private boolean addTicket(long p_219347_1_, Ticket<?> p_219347_3_) {
       SortedArraySet<Ticket<?>> sortedarrayset = this.func_229848_e_(p_219347_1_);
       int i = func_229844_a_(sortedarrayset);
       Ticket<?> ticket = sortedarrayset.func_226175_a_(p_219347_3_);
@@ -143,36 +_,226 @@
          this.field_219378_f.func_215491_b(p_219347_1_, p_219347_3_.func_219477_b(), true);
       }
 
-   }
-
-   private void func_219349_b(long p_219349_1_, Ticket<?> p_219349_3_) {
-      SortedArraySet<Ticket<?>> sortedarrayset = this.func_229848_e_(p_219349_1_);
-      if (sortedarrayset.remove(p_219349_3_)) {
-      }
-
-      if (sortedarrayset.isEmpty()) {
-         this.field_219377_e.remove(p_219349_1_);
-      }
-
-      this.field_219378_f.func_215491_b(p_219349_1_, func_229844_a_(sortedarrayset), false);
+      if (p_219347_3_.isForceTicks()) {
+          SortedArraySet<Ticket<?>> tickets = forcedTickets.computeIfAbsent(p_219347_1_, e -> SortedArraySet.func_226172_a_(4));
+          tickets.func_226175_a_(ticket);
+      }
+
+      return ticket == p_219347_3_;
+   }
+
+   private boolean removeTicket(long i, Ticket<?> ticket) {
+      AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
+      SortedArraySet<Ticket<?>> arraysetsorted = this.func_229848_e_(i);
+      int oldLevel = func_229844_a_(arraysetsorted); // Paper
+
+      boolean removed = false; // CraftBukkit
+      if (arraysetsorted.remove(ticket)) {
+         removed = true; // CraftBukkit
+         // Paper start - delay chunk unloads for player tickets
+         long delayChunkUnloadsBy = chunkMap.field_219255_i.paperConfig.delayChunkUnloadsBy;
+         if (ticket.func_219479_a() == TicketType.field_219490_c && delayChunkUnloadsBy > 0) {
+            boolean hasPlayer = false;
+            for (Ticket<?> ticket1 : arraysetsorted) {
+               if (ticket1.func_219479_a() == TicketType.field_219490_c) {
+                  hasPlayer = true;
+                  break;
+               }
+            }
+            ChunkHolder playerChunk = chunkMap.func_219220_a(i);
+            if (!hasPlayer && playerChunk != null && playerChunk.isFullChunkReady()) {
+               Ticket<Long> delayUnload = new Ticket<Long>(TicketType.DELAY_UNLOAD, 33, i);
+               delayUnload.delayUnloadBy = delayChunkUnloadsBy;
+               delayUnload.func_229861_a_(this.field_219389_q);
+               arraysetsorted.remove(delayUnload);
+               // refresh ticket
+               arraysetsorted.add(delayUnload);
+            }
+         }
+         // Paper end
+      }
+
+      if (arraysetsorted.isEmpty()) {
+         this.field_219377_e.remove(i);
+      }
+
+      int newLevel = func_229844_a_(arraysetsorted); // Paper
+      if (newLevel > oldLevel) this.field_219378_f.func_215491_b(i, newLevel, false); // Paper
+
+      if (ticket.isForceTicks()) {
+          SortedArraySet<Ticket<?>> tickets = forcedTickets.get(i);
+          if (tickets != null) {
+              tickets.remove(ticket);
+          }
+      }
+
+      return removed; // CraftBukkit
+//      SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(p_219349_1_);
+//      if (sortedarrayset.remove(p_219349_3_)) {
+//      }
+//
+//      if (sortedarrayset.isEmpty()) {
+//         this.tickets.remove(p_219349_1_);
+//      }
+//
+//      this.ticketTracker.update(p_219349_1_, getTicketLevelAt(sortedarrayset), false);
+//
+//      if (p_219349_3_.isForceTicks()) {
+//          SortedArraySet<Ticket<?>> tickets = forcedTickets.get(p_219349_1_);
+//          if (tickets != null) {
+//              tickets.remove(p_219349_3_);
+//          }
+//      }
+   }
+
+   // Paper start
+   public static final int PRIORITY_TICKET_LEVEL = ChunkManager.field_219249_a;
+   public static final int URGENT_PRIORITY = 29;
+   public boolean delayDistanceManagerTick = false;
+
+   public boolean markUrgent(ChunkPos coords) {
+      return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
+   }
+
+   public boolean markHighPriority(ChunkPos coords, int priority) {
+      priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+      return addPriorityTicket(coords, TicketType.PRIORITY, priority);
+   }
+
+   public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+      delayDistanceManagerTick = true;
+      priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+      int finalPriority = priority;
+      MCUtil.getSpiralOutChunks(center.func_206849_h(), radius).forEach(coords -> {
+         addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
+      });
+      delayDistanceManagerTick = false;
+      chunkMap.field_219255_i.func_72863_F().func_217235_l();
+   }
+
+   public void clearUrgent(ChunkPos coords) {
+      AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
+      this.removeTicket(coords.func_201841_a(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
+   }
+
+   private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
+      AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
+      long pair = coords.func_201841_a();
+      ChunkHolder chunk = chunkMap.func_219220_a(pair);
+      boolean needsTicket = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(pair) != null && !hasPlayerTicket(coords, 33);
+
+      if (needsTicket) {
+         Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, 33, coords);
+         field_219387_o.add(pair);
+         addTicket(pair, ticket);
+      }
+      if ((chunk != null && chunk.isFullChunkReady())) {
+         if (needsTicket) {
+            chunkMap.field_219255_i.func_72863_F().func_217235_l();
+         }
+         return needsTicket;
+      }
+
+      boolean success;
+      if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
+         Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
+         ticket.priority = priority;
+         success = this.addTicket(pair, ticket);
+      } else {
+         if (chunk == null) {
+            chunk = chunkMap.func_219220_a(pair);
+         }
+         chunkMap.queueHolderUpdate(chunk);
+      }
+
+      //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
+
+      chunkMap.field_219255_i.func_72863_F().func_217235_l();
+
+      return success;
+   }
+
+   private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
+      SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+      if (tickets == null) {
+         return false;
+      }
+      for (Ticket<?> ticket : tickets) {
+         if (ticket.func_219479_a() == type) {
+            // We only support increasing, not decreasing, too complicated
+            ticket.func_229861_a_(this.field_219389_q);
+            ticket.priority = Math.max(ticket.priority, priority);
+            return true;
+         }
+      }
+
+      return false;
+   }
+
+   public int getChunkPriority(ChunkPos coords) {
+      AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
+      SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+      if (tickets == null) {
+         return 0;
+      }
+      for (Ticket<?> ticket : tickets) {
+         if (ticket.func_219479_a() == TicketType.URGENT) {
+            return URGENT_PRIORITY;
+         }
+      }
+      for (Ticket<?> ticket : tickets) {
+         if (ticket.func_219479_a() == TicketType.PRIORITY && ticket.priority > 0) {
+            return ticket.priority;
+         }
+      }
+      return 0;
+   }
+
+
+   private boolean hasPlayerTicket(ChunkPos coords, int level) {
+      SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+      if (tickets == null || tickets.isEmpty()) {
+         return false;
+      }
+      for (Ticket<?> ticket : tickets) {
+         if (ticket.func_219479_a() == TicketType.field_219490_c && ticket.func_219477_b() == level) {
+            return true;
+         }
+      }
+
+      return false;
+   }
+
+
+   public void clearPriorityTickets(ChunkPos coords) {
+      AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
+      this.removeTicket(coords.func_201841_a(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
    }
 
    public <T> void func_219356_a(TicketType<T> p_219356_1_, ChunkPos p_219356_2_, int p_219356_3_, T p_219356_4_) {
-      this.func_219347_a(p_219356_2_.func_201841_a(), new Ticket<>(p_219356_1_, p_219356_3_, p_219356_4_));
+      this.addTicket(p_219356_2_.func_201841_a(), new Ticket<>(p_219356_1_, p_219356_3_, p_219356_4_));
    }
 
    public <T> void func_219345_b(TicketType<T> p_219345_1_, ChunkPos p_219345_2_, int p_219345_3_, T p_219345_4_) {
       Ticket<T> ticket = new Ticket<>(p_219345_1_, p_219345_3_, p_219345_4_);
-      this.func_219349_b(p_219345_2_.func_201841_a(), ticket);
+      this.removeTicket(p_219345_2_.func_201841_a(), ticket);
    }
 
    public <T> void func_219331_c(TicketType<T> p_219331_1_, ChunkPos p_219331_2_, int p_219331_3_, T p_219331_4_) {
-      this.func_219347_a(p_219331_2_.func_201841_a(), new Ticket<>(p_219331_1_, 33 - p_219331_3_, p_219331_4_));
+      this.addTicket(p_219331_2_.func_201841_a(), new Ticket<>(p_219331_1_, 33 - p_219331_3_, p_219331_4_));
    }
 
    public <T> void func_219362_d(TicketType<T> p_219362_1_, ChunkPos p_219362_2_, int p_219362_3_, T p_219362_4_) {
       Ticket<T> ticket = new Ticket<>(p_219362_1_, 33 - p_219362_3_, p_219362_4_);
-      this.func_219349_b(p_219362_2_.func_201841_a(), ticket);
+      this.removeTicket(p_219362_2_.func_201841_a(), ticket);
+   }
+
+   public <T> void registerTicking(TicketType<T> type, ChunkPos pos, int distance, T value) {
+      this.addTicket(pos.func_201841_a(), new Ticket<>(type, 33 - distance, value, true));
+   }
+
+   public <T> void releaseTicking(TicketType<T> type, ChunkPos pos, int distance, T value) {
+      this.removeTicket(pos.func_201841_a(), new Ticket<>(type, 33 - distance, value, true));
    }
 
    private SortedArraySet<Ticket<?>> func_229848_e_(long p_229848_1_) {
@@ -184,9 +_,9 @@
    protected void func_219364_a(ChunkPos p_219364_1_, boolean p_219364_2_) {
       Ticket<ChunkPos> ticket = new Ticket<>(TicketType.field_219491_d, 31, p_219364_1_);
       if (p_219364_2_) {
-         this.func_219347_a(p_219364_1_.func_201841_a(), ticket);
+         this.addTicket(p_219364_1_.func_201841_a(), ticket);
       } else {
-         this.func_219349_b(p_219364_1_.func_201841_a(), ticket);
+         this.removeTicket(p_219364_1_.func_201841_a(), ticket);
       }
 
    }
@@ -196,7 +_,7 @@
       this.field_219375_c.computeIfAbsent(i, (p_219361_0_) -> {
          return new ObjectOpenHashSet();
       }).add(p_219341_2_);
-      this.field_219381_i.func_215491_b(i, 0, true);
+      //this.naturalSpawnChunkCounter.update(i, 0, true);
       this.field_219382_j.func_215491_b(i, 0, true);
    }
 
@@ -206,7 +_,7 @@
       objectset.remove(p_219367_2_);
       if (objectset.isEmpty()) {
          this.field_219375_c.remove(i);
-         this.field_219381_i.func_215491_b(i, Integer.MAX_VALUE, false);
+         //this.naturalSpawnChunkCounter.update(i, Integer.MAX_VALUE, false);
          this.field_219382_j.func_215491_b(i, Integer.MAX_VALUE, false);
       }
 
@@ -224,24 +_,37 @@
       return s;
    }
 
-   protected void func_219354_b(int p_219354_1_) {
+   protected void setNoTickViewDistance(int p_219354_1_) { // Paper - force abi breakage on usage change
       this.field_219382_j.func_215508_a(p_219354_1_);
    }
 
    public int func_219358_b() {
-      this.field_219381_i.func_215497_a();
-      return this.field_219381_i.field_215498_a.size();
+      // Paper start - use distance map to implement
+      // note: this is the spawn chunk count
+      return this.chunkMap.playerChunkTickRangeMap.size();
+      // Paper end - use distance map to implement
+//      this.naturalSpawnChunkCounter.runAllUpdates();
+//      return this.naturalSpawnChunkCounter.chunks.size();
    }
 
    public boolean func_223494_d(long p_223494_1_) {
-      this.field_219381_i.func_215497_a();
-      return this.field_219381_i.field_215498_a.containsKey(p_223494_1_);
+      // Paper start - use distance map to implement
+      // note: this is the is spawn chunk method
+      return this.chunkMap.playerChunkTickRangeMap.getObjectsInRange(p_223494_1_) != null;
+      // Paper end - use distance map to implement
+//      this.naturalSpawnChunkCounter.runAllUpdates();
+//      return this.naturalSpawnChunkCounter.chunks.containsKey(p_223494_1_);
    }
 
    public String func_225412_c() {
       return this.field_219384_l.func_225396_a();
    }
 
+   public boolean shouldForceTicks(long chunkPos) {
+       SortedArraySet<Ticket<?>> tickets = forcedTickets.get(chunkPos);
+       return tickets != null && !tickets.isEmpty();
+   }
+
    class ChunkTicketTracker extends ChunkDistanceGraph {
       public ChunkTicketTracker() {
          super(ChunkManager.field_219249_a + 2, 16, 256);
@@ -353,32 +_,153 @@
 
       private void func_215504_a(long p_215504_1_, int p_215504_3_, boolean p_215504_4_, boolean p_215504_5_) {
          if (p_215504_4_ != p_215504_5_) {
-            Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, TicketManager.field_219374_b, new ChunkPos(p_215504_1_));
+            ChunkPos coords = new ChunkPos(p_215504_1_); // Paper
+            Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, 33, coords); // Paper - no-tick view distance
             if (p_215504_5_) {
-               TicketManager.this.field_219385_m.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(() -> {
-                  TicketManager.this.field_219388_p.execute(() -> {
-                     if (this.func_215505_c(this.func_215471_c(p_215504_1_))) {
-                        TicketManager.this.func_219347_a(p_215504_1_, ticket);
-                        TicketManager.this.field_219387_o.add(p_215504_1_);
-                     } else {
-                        TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
-                        }, p_215504_1_, false));
-                     }
+               scheduleChunkLoad(p_215504_1_, MinecraftServer.currentTick, p_215504_3_, (priority) -> { // Paper - smarter ticket delay based on frustum and distance
+                  // Paper start - recheck its still valid if not cancel
+                  if (!isChunkInRange(p_215504_1_)) {
+                     TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
+                        TicketManager.this.field_219388_p.execute(() -> {
+                           TicketManager.this.removeTicket(p_215504_1_, ticket);
+                           TicketManager.this.clearPriorityTickets(coords);
+                        });
+                     }, p_215504_1_, false));
+                     return;
+                  }
+                  // abort early if we got a ticket already
+                  if (hasPlayerTicket(coords, 33)) return;
+                  // skip player ticket throttle for near chunks
+                  if (priority <= 3) {
+                     TicketManager.this.addTicket(p_215504_1_, ticket);
+                     TicketManager.this.field_219387_o.add(p_215504_1_);
+                     return;
+                  }
+                  // Paper end
 
-                  });
-               }, p_215504_1_, () -> {
-                  return p_215504_3_;
-               }));
+                  TicketManager.this.field_219385_m.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(() -> {
+                     TicketManager.this.field_219388_p.execute(() -> {
+                        if (isChunkInRange(p_215504_1_)) {
+                           if (!hasPlayerTicket(coords, 33)) { // Paper - high priority might of already added it
+                              TicketManager.this.addTicket(p_215504_1_, ticket);
+                              TicketManager.this.field_219387_o.add(p_215504_1_);
+                           }
+                        } else { // Paper
+                           TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> { // CraftBukkit - decompile error
+                           }, p_215504_1_, false));
+                        }
+                     });
+                  }, p_215504_1_, () -> {
+                     return p_215504_3_;
+                  }));
+               }); // Paper
             } else {
                TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
                   TicketManager.this.field_219388_p.execute(() -> {
-                     TicketManager.this.func_219349_b(p_215504_1_, ticket);
+                     TicketManager.this.removeTicket(p_215504_1_, ticket);
+                     TicketManager.this.clearPriorityTickets(coords); // Paper
                   });
                }, p_215504_1_, true));
             }
          }
 
       }
+
+      // Paper start - smart scheduling of player tickets
+      private boolean isChunkInRange(long i) {
+         return this.func_215505_c(this.func_215471_c(i));
+      }
+      public void scheduleChunkLoad(long i, long startTick, int initialDistance, java.util.function.Consumer<Integer> task) {
+         long elapsed = MinecraftServer.currentTick - startTick;
+         ChunkPos chunkPos = new ChunkPos(i);
+         ChunkHolder updatingChunk = chunkMap.func_219220_a(i);
+         if ((updatingChunk != null && updatingChunk.isFullChunkReady()) || !isChunkInRange(i) || getChunkPriority(chunkPos) > 0) { // Copied from above
+            // no longer needed
+            task.accept(1);
+            return;
+         }
+
+         int desireDelay = 0;
+         double minDist = Double.MAX_VALUE;
+         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> players = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(i);
+         if (elapsed == 0 && initialDistance <= 4) {
+            // Aim for no delay on initial 6 chunk radius tickets save on performance of the below code to only > 6
+            minDist = initialDistance;
+         } else if (players != null) {
+            Object[] backingSet = players.getBackingSet();
+
+            BlockPos blockPos = chunkPos.func_206849_h();
+
+            boolean isFront = false;
+            BlockPos.Mutable pos = new BlockPos.Mutable();
+            for (int index = 0, len = backingSet.length; index < len; ++index) {
+               if (!(backingSet[index] instanceof ServerPlayerEntity)) {
+                  continue;
+               }
+               ServerPlayerEntity player = (ServerPlayerEntity) backingSet[index];
+
+               ChunkPos pointInFront = player.getChunkInFront(5);
+               pos.func_181079_c(pointInFront.field_77276_a << 4, 0, pointInFront.field_77275_b << 4);
+               double frontDist = MCUtil.distanceSq(pos, blockPos);
+
+               pos.func_189532_c(player.func_226277_ct_(), 0, player.func_226281_cx_());
+               double center = MCUtil.distanceSq(pos, blockPos);
+
+               double dist = Math.min(frontDist, center);
+               if (!isFront) {
+                  ChunkPos pointInBack = player.getChunkInFront(-7);
+                  pos.func_181079_c(pointInBack.field_77276_a << 4, 0, pointInBack.field_77275_b << 4);
+                  double backDist = MCUtil.distanceSq(pos, blockPos);
+                  if (frontDist < backDist) {
+                     isFront = true;
+                  }
+               }
+               if (dist < minDist) {
+                  minDist = dist;
+               }
+            }
+            if (minDist == Double.MAX_VALUE) {
+               minDist = 15;
+            } else {
+               minDist = Math.sqrt(minDist) / 16;
+            }
+            if (minDist > 4) {
+               int desiredTimeDelayMax = isFront ?
+                       (minDist < 10 ? 7 : 15) : // Front
+                       (minDist < 10 ? 15 : 45); // Back
+               desireDelay += (desiredTimeDelayMax * 20) * (minDist / 32);
+            }
+         } else {
+            minDist = initialDistance;
+            desireDelay = 1;
+         }
+         long delay = desireDelay - elapsed;
+         if (delay <= 0 && minDist > 4 && minDist < Double.MAX_VALUE) {
+            boolean hasAnyNeighbor = false;
+            for (int x = -1; x <= 1; x++) {
+               for (int z = -1; z <= 1; z++) {
+                  if (x == 0 && z == 0) continue;
+                  long pair = ChunkPos.func_77272_a(chunkPos.field_77276_a + x, chunkPos.field_77275_b + z);
+                  ChunkHolder neighbor = chunkMap.func_219220_a(pair);
+                  ChunkStatus current = neighbor != null ? neighbor.getChunkHolderStatus() : null;
+                  if (current != null && current.func_209003_a(ChunkStatus.field_222614_j)) {
+                     hasAnyNeighbor = true;
+                  }
+               }
+            }
+            if (!hasAnyNeighbor) {
+               delay += 20;
+            }
+         }
+         if (delay <= 0) {
+            task.accept((int) minDist);
+         } else {
+            int taskDelay = (int) Math.min(delay, minDist >= 10 ? 40 : (minDist < 6 ? 5 : 20));
+            MCUtil.scheduleTask(taskDelay, () -> scheduleChunkLoad(i, startTick, initialDistance, task), "Player Ticket Delayer");
+         }
+      }
+      // Paper end
+
 
       public void func_215497_a() {
          super.func_215497_a();
