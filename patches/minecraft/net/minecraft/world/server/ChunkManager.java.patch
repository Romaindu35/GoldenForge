--- a/net/minecraft/world/server/ChunkManager.java
+++ b/net/minecraft/world/server/ChunkManager.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.server;
 
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -30,10 +_,7 @@
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
-import java.util.function.IntFunction;
-import java.util.function.IntSupplier;
-import java.util.function.Supplier;
+import java.util.function.*;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -55,6 +_,7 @@
 import net.minecraft.network.play.server.SUpdateChunkPositionPacket;
 import net.minecraft.network.play.server.SUpdateLightPacket;
 import net.minecraft.profiler.IProfiler;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.CSVWriter;
 import net.minecraft.util.ClassInheritanceMultiMap;
 import net.minecraft.util.Util;
@@ -81,6 +_,7 @@
 import net.minecraft.world.chunk.listener.IChunkStatusListener;
 import net.minecraft.world.chunk.storage.ChunkLoader;
 import net.minecraft.world.chunk.storage.ChunkSerializer;
+import net.minecraft.world.chunk.storage.RegionFile;
 import net.minecraft.world.gen.ChunkGenerator;
 import net.minecraft.world.gen.feature.structure.StructureStart;
 import net.minecraft.world.gen.feature.template.TemplateManager;
@@ -91,29 +_,30 @@
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProvider {
    private static final Logger field_219250_d = LogManager.getLogger();
    public static final int field_219249_a = 33 + ChunkStatus.func_222600_b();
-   private final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219251_e = new Long2ObjectLinkedOpenHashMap<>();
-   private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219252_f = this.field_219251_e.clone();
+   public final com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<ChunkHolder> updatingChunks = new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<>();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219253_g = new Long2ObjectLinkedOpenHashMap<>();
    private final LongSet field_219254_h = new LongOpenHashSet();
-   private final ServerWorld field_219255_i;
+   public final ServerWorld field_219255_i;
    private final ServerWorldLightManager field_219256_j;
    private final ThreadTaskExecutor<Runnable> field_219257_k;
+   final java.util.concurrent.Executor mainInvokingExecutor; // Paper
    private final ChunkGenerator field_219258_l;
-   private final Supplier<DimensionSavedDataManager> field_219259_m;
+   public final Supplier<DimensionSavedDataManager> field_219259_m;
    private final PointOfInterestManager field_219260_n;
    private final LongSet field_219261_o = new LongOpenHashSet();
    private boolean field_219262_p;
    private final ChunkTaskPriorityQueueSorter field_219263_q;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219264_r;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219265_s;
-   private final IChunkStatusListener field_219266_t;
-   private final ChunkManager.ProxyTicketManager field_219267_u;
+   public final IChunkStatusListener field_219266_t;
+   public final ChunkManager.ProxyTicketManager field_219267_u;
    private final AtomicInteger field_219268_v = new AtomicInteger();
-   private final TemplateManager field_219269_w;
+   public final TemplateManager field_219269_w;
    private final File field_219270_x;
    private final PlayerGenerationTracker field_219271_y = new PlayerGenerationTracker();
    private final Int2ObjectMap<ChunkManager.EntityTracker> field_219272_z = new Int2ObjectOpenHashMap<>();
@@ -121,6 +_,154 @@
    private final Queue<Runnable> field_223181_A = Queues.newConcurrentLinkedQueue();
    private int field_219247_A;
 
+   // GoldenForge start
+   public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+   public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
+      // Tuinity start - revert paper's change
+      private Runnable queued;
+
+      @Override
+      public void execute(Runnable runnable) {
+         AsyncCatcher.catchOp("Callback Executor execute");
+         if (queued != null) {
+            MinecraftServer.field_147145_h.fatal("Failed to schedule runnable", new IllegalStateException("Already queued")); // Paper - make sure this is printed
+            throw new IllegalStateException("Already queued");
+         }
+         queued = runnable;
+      }
+      // Tuinity end - revert paper's change
+
+      @Override
+      public void run() {
+         AsyncCatcher.catchOp("Callback Executor run");
+         // Tuinity start - revert paper's change
+         Runnable task = queued;
+         queued = null;
+         if (task != null) {
+            // Tuinity end - revert paper's change
+            task.run();
+         }
+      }
+      // Paper end
+   };
+   // CraftBukkit end
+
+   final CallbackExecutor chunkLoadConversionCallbackExecutor = new CallbackExecutor(); // Paper
+
+   public final int getEffectiveViewDistance() {
+      // TODO this needs to be checked on update
+      // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
+      return this.field_219247_A - 1;
+   }
+   // GoldenForge end
+
+   // GoldenForge - replace chunk loader
+   private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<ServerPlayerEntity> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+   public final com.tuinity.tuinity.chunk.PlayerChunkLoader playerChunkManager = new com.tuinity.tuinity.chunk.PlayerChunkLoader(this, this.pooledLinkedPlayerHashSets);
+
+   public static final int GENERAL_AREA_MAP_SQUARE_RADIUS = 38;
+   public static final double GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE = 16.0 * (GENERAL_AREA_MAP_SQUARE_RADIUS - 1);
+   public static final double GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE_SQUARED = GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE * GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE;
+   // GoldenForge end
+
+   // GoldenForge - no tick view distance
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerGeneralAreaMap;
+   static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap[] playerEntityTrackerTrackMaps;
+   final int[] entityTrackerTrackRanges; public int getEntityTrackerRange(final int ordinal) { return this.entityTrackerTrackRanges[ordinal]; } // Tuinity - public read
+
+   void addPlayerToDistanceMaps(ServerPlayerEntity player) {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update distance maps off of the main thread"); // Tuinity
+      int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+      int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+      // Note: players need to be explicitly added to distance maps before they can be updated
+      // Paper start - use distance map to optimise entity tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+         int trackRange = this.entityTrackerTrackRanges[i];
+
+         trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getViewDistance())); // Tuinity - per player view distances
+      }
+      // Paper end - use distance map to optimise entity tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerChunkTickRangeMap.add(player, chunkX, chunkZ, TicketManager.MOB_SPAWN_RANGE);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      this.playerChunkManager.addPlayer(player); // Tuinity - replace chunk loader
+      // Paper end - no-tick view distance
+      // Tuinity start - optimise checkDespawn
+      this.playerGeneralAreaMap.add(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS);
+      // Tuinity end - optimise checkDespawn
+   }
+
+   void removePlayerFromDistanceMaps(ServerPlayerEntity player) {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update distance maps off of the main thread"); // Tuinity
+      // Paper start - use distance map to optimise tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         this.playerEntityTrackerTrackMaps[i].remove(player);
+      }
+      // Paper end - use distance map to optimise tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      //this.playerMobSpawnMap.remove(player);
+      this.playerChunkTickRangeMap.remove(player);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      this.playerChunkManager.removePlayer(player); // Tuinity - replace chunk loader
+      // Paper end - no-tick view distance
+      // Tuinity start - optimise checkDespawn
+      this.playerGeneralAreaMap.remove(player);
+      // Tuinity end - optimise checkDespawn
+   }
+
+   void updateMaps(ServerPlayerEntity player) {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update distance maps off of the main thread"); // Tuinity
+      int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+      int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+      // Note: players need to be explicitly added to distance maps before they can be updated
+      // Paper start - use distance map to optimise entity tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+         int trackRange = this.entityTrackerTrackRanges[i];
+
+         trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getViewDistance())); // Tuinity - per player view distances
+      }
+      // Paper end - use distance map to optimise entity tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, TicketManager.MOB_SPAWN_RANGE);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      this.playerChunkManager.updatePlayer(player); // Tuinity - replace chunk loader
+      // Paper end - no-tick view distance
+      // Tuinity start - optimise checkDespawn
+      this.playerGeneralAreaMap.update(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS);
+      // Tuinity end - optimise checkDespawn
+   }
+   // Paper end
+   // GoldenForge end
+
+   public void queueHolderUpdate(ChunkHolder playerchunk) {
+      Runnable runnable = () -> {
+         if (isUnloading(playerchunk)) {
+            return; // unloaded
+         }
+         field_219267_u.field_219383_k.add(playerchunk);
+         if (!field_219267_u.pollingPendingChunkUpdates) {
+            field_219255_i.func_72863_F().func_217235_l();
+         }
+      };
+      if (MCUtil.isMainThread()) {
+         // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
+         runnable.run();
+      } else {
+         field_219257_k.execute(runnable);
+      }
+   }
+
+   private boolean isUnloading(ChunkHolder playerchunk) {
+      return playerchunk == null || field_219261_o.contains(playerchunk.func_219277_h().func_201841_a());
+   }
+
    public ChunkManager(ServerWorld p_i232602_1_, SaveFormat.LevelSave p_i232602_2_, DataFixer p_i232602_3_, TemplateManager p_i232602_4_, Executor p_i232602_5_, ThreadTaskExecutor<Runnable> p_i232602_6_, IChunkLightProvider p_i232602_7_, ChunkGenerator p_i232602_8_, IChunkStatusListener p_i232602_9_, Supplier<DimensionSavedDataManager> p_i232602_10_, int p_i232602_11_, boolean p_i232602_12_) {
       super(new File(p_i232602_2_.func_237291_a_(p_i232602_1_.func_234923_W_()), "region"), p_i232602_3_, p_i232602_12_);
       this.field_219269_w = p_i232602_4_;
@@ -128,6 +_,15 @@
       this.field_219255_i = p_i232602_1_;
       this.field_219258_l = p_i232602_8_;
       this.field_219257_k = p_i232602_6_;
+      // Paper start
+      this.mainInvokingExecutor = (run) -> {
+         if (MCUtil.isMainThread()) {
+            run.run();
+         } else {
+            p_i232602_6_.execute(run);
+         }
+      };
+      // Paper end
       DelegatedTaskExecutor<Runnable> delegatedtaskexecutor = DelegatedTaskExecutor.func_213144_a(p_i232602_5_, "worldgen");
       ITaskExecutor<Runnable> itaskexecutor = ITaskExecutor.func_213140_a("main", p_i232602_6_::func_212871_a_);
       this.field_219266_t = p_i232602_9_;
@@ -136,10 +_,83 @@
       this.field_219264_r = this.field_219263_q.func_219087_a(delegatedtaskexecutor, false);
       this.field_219265_s = this.field_219263_q.func_219087_a(itaskexecutor, false);
       this.field_219256_j = new ServerWorldLightManager(p_i232602_7_, this, this.field_219255_i.func_230315_m_().func_218272_d(), delegatedtaskexecutor1, this.field_219263_q.func_219087_a(delegatedtaskexecutor1, false));
-      this.field_219267_u = new ChunkManager.ProxyTicketManager(p_i232602_5_, p_i232602_6_);
+      this.field_219267_u = new ChunkManager.ProxyTicketManager(p_i232602_5_, p_i232602_6_); this.field_219267_u.chunkMap = this; // Paper
       this.field_219259_m = p_i232602_10_;
-      this.field_219260_n = new PointOfInterestManager(new File(this.field_219270_x, "poi"), p_i232602_3_, p_i232602_12_);
+      this.field_219260_n = new PointOfInterestManager(new File(this.field_219270_x, "poi"), p_i232602_3_, p_i232602_12_, field_219255_i);
       this.func_219175_a(p_i232602_11_);
+      // Paper start - use distance map to optimise entity tracker
+      this.playerEntityTrackerTrackMaps = new com.destroystokyo.paper.util.misc.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+      this.entityTrackerTrackRanges = new int[TRACKING_RANGE_TYPES.length];
+
+      org.spigotmc.SpigotWorldConfig spigotWorldConfig = this.field_219255_i.spigotConfig;
+
+      for (int ordinal = 0, len = TRACKING_RANGE_TYPES.length; ordinal < len; ++ordinal) {
+         org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = TRACKING_RANGE_TYPES[ordinal];
+         int configuredSpigotValue;
+         switch (trackingRangeType) {
+            case PLAYER:
+               configuredSpigotValue = spigotWorldConfig.playerTrackingRange;
+               break;
+            case ANIMAL:
+               configuredSpigotValue = spigotWorldConfig.animalTrackingRange;
+               break;
+            case MONSTER:
+               configuredSpigotValue = spigotWorldConfig.monsterTrackingRange;
+               break;
+            case MISC:
+               configuredSpigotValue = spigotWorldConfig.miscTrackingRange;
+               break;
+            case OTHER:
+               configuredSpigotValue = spigotWorldConfig.otherTrackingRange;
+               break;
+            case ENDERDRAGON:
+               configuredSpigotValue = EntityType.field_200802_p.field_233594_bl_ * 16;
+               break;
+            default:
+               throw new IllegalStateException("Missing case for enum " + trackingRangeType);
+         }
+         configuredSpigotValue = MinecraftServer.getServer().func_230512_b_(configuredSpigotValue);
+
+         int trackRange = (configuredSpigotValue >>> 4) + ((configuredSpigotValue & 15) != 0 ? 1 : 0);
+         this.entityTrackerTrackRanges[ordinal] = trackRange;
+
+         this.playerEntityTrackerTrackMaps[ordinal] = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+      }
+      // Paper end - use distance map to optimise entity tracker
+      this.setNoTickViewDistance(this.field_219255_i.paperConfig.noTickViewDistance);
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                 }
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                 }
+              });
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+
+      this.playerGeneralAreaMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 Chunk chunk = ChunkManager.this.field_219255_i.func_72863_F().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                 if (chunk != null) {
+                    chunk.updateGeneralAreaCache(newState);
+                 }
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 Chunk chunk = ChunkManager.this.field_219255_i.func_72863_F().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                 if (chunk != null) {
+                    chunk.updateGeneralAreaCache(newState);
+                 }
+              });
    }
 
    private static double func_219217_a(ChunkPos p_219217_0_, Entity p_219217_1_) {
@@ -176,13 +_,27 @@
    }
 
    @Nullable
-   protected ChunkHolder func_219220_a(long p_219220_1_) {
-      return this.field_219251_e.get(p_219220_1_);
-   }
+   public ChunkHolder func_219220_a(long p_219220_1_) {
+      return this.updatingChunks.getUpdating(p_219220_1_); // Tuinity - Don't copy
+   }
+
+   public Long2ObjectLinkedOpenHashMap<ChunkHolder> getVisibleChunks() {
+      // Tuinity start - Don't copy (except in rare cases)
+      synchronized (this.updatingChunks) {
+         return this.updatingChunks.getVisibleMap().clone();
+      }
+      // Tuinity end - Don't copy (except in rare cases)
+   }
+   // Paper end
 
    @Nullable
-   protected ChunkHolder func_219219_b(long p_219219_1_) {
-      return this.field_219252_f.get(p_219219_1_);
+   public ChunkHolder func_219219_b(long p_219219_1_) {
+      // Tuinity start - Don't copy
+      if (Thread.currentThread() == this.field_219255_i.field_217407_c) {
+         return this.updatingChunks.getVisible(p_219219_1_);
+      }
+      return this.updatingChunks.getVisibleAsync(p_219219_1_);
+      // Tuinity end - Don't copy
    }
 
    protected IntSupplier func_219191_c(long p_219191_1_) {
@@ -219,6 +_,7 @@
       List<CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>>> list = Lists.newArrayList();
       int i = p_219236_1_.field_77276_a;
       int j = p_219236_1_.field_77275_b;
+      ChunkHolder requestingNeighbor = func_219220_a(p_219236_1_.func_201841_a()); // Paper
 
       for(int k = -p_219236_2_; k <= p_219236_2_; ++k) {
          for(int l = -p_219236_2_; l <= p_219236_2_; ++l) {
@@ -236,6 +_,14 @@
 
             ChunkStatus chunkstatus = p_219236_3_.apply(i1);
             CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = chunkholder.func_219276_a(chunkstatus, this);
+            // Paper start
+            if (requestingNeighbor != null && requestingNeighbor != chunkholder && !completablefuture.isDone()) {
+               requestingNeighbor.onNeighborRequest(chunkholder, chunkstatus);
+               completablefuture.thenAccept(either -> {
+                  requestingNeighbor.onNeighborDone(chunkholder, chunkstatus, either.left().orElse(null));
+               });
+            }
+            // Paper end
             list.add(completablefuture);
          }
       }
@@ -271,16 +_,19 @@
          return p_219242_0_.mapLeft((p_219238_0_) -> {
             return (Chunk)p_219238_0_.get(p_219238_0_.size() / 2);
          });
-      }, this.field_219257_k);
+      }, this.mainInvokingExecutor); // Paper
    }
 
    @Nullable
    private ChunkHolder func_219213_a(long p_219213_1_, int p_219213_3_, @Nullable ChunkHolder p_219213_4_, int p_219213_5_) {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Chunk holder update"); // Tuinity
+      if (this.unloadingPlayerChunk) { MinecraftServer.field_147145_h.fatal("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Tuinity
       if (p_219213_5_ > field_219249_a && p_219213_3_ > field_219249_a) {
          return p_219213_4_;
       } else {
          if (p_219213_4_ != null) {
             p_219213_4_.func_219292_a(p_219213_3_);
+            p_219213_4_.updateRanges();
          }
 
          if (p_219213_4_ != null) {
@@ -299,7 +_,7 @@
                p_219213_4_ = new ChunkHolder(new ChunkPos(p_219213_1_), p_219213_3_, this.field_219256_j, this.field_219263_q, this);
             }
 
-            this.field_219251_e.put(p_219213_1_, p_219213_4_);
+            this.updatingChunks.queueUpdate(p_219213_1_, p_219213_4_); // Tuinity - Don't copy
             this.field_219262_p = true;
          }
 
@@ -310,6 +_,7 @@
    public void close() throws IOException {
       try {
          this.field_219263_q.close();
+         this.field_219255_i.asyncChunkTaskManager.close(true); // Paper - Required since we're closing regionfiles in the next line
          this.field_219260_n.close();
       } finally {
          super.close();
@@ -318,8 +_,9 @@
    }
 
    protected void func_219177_a(boolean p_219177_1_) {
+      Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = this.getVisibleChunks(); // Paper remove clone of visible Chunks unless saving off main thread (watchdog kill)
       if (p_219177_1_) {
-         List<ChunkHolder> list = this.field_219252_f.values().stream().filter(ChunkHolder::func_219289_k).peek(ChunkHolder::func_219303_l).collect(Collectors.toList());
+         List<ChunkHolder> list = visibleChunks.values().stream().filter(ChunkHolder::func_219289_k).peek(ChunkHolder::func_219303_l).collect(Collectors.toList());
          MutableBoolean mutableboolean = new MutableBoolean();
 
          do {
@@ -342,10 +_,11 @@
          this.func_223155_b(() -> {
             return true;
          });
-         this.func_227079_i_();
+         //this.flushWorker();
+         this.field_219255_i.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
          field_219250_d.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.field_219270_x.getName());
       } else {
-         this.field_219252_f.values().stream().filter(ChunkHolder::func_219289_k).forEach((p_222965_1_) -> {
+         visibleChunks.values().stream().filter(ChunkHolder::func_219289_k).forEach((p_222965_1_) -> {
             IChunk ichunk = p_222965_1_.func_219302_f().getNow((IChunk)null);
             if (ichunk instanceof ChunkPrimerWrapper || ichunk instanceof Chunk) {
                this.func_219229_a(ichunk);
@@ -356,6 +_,7 @@
       }
 
    }
+   private static final double UNLOAD_QUEUE_RESIZE_FACTOR = 0.90; // Spigot // Paper - unload more
 
    protected void func_219204_a(BooleanSupplier p_219204_1_) {
       IProfiler iprofiler = this.field_219255_i.func_217381_Z();
@@ -371,50 +_,195 @@
 
    private void func_223155_b(BooleanSupplier p_223155_1_) {
       LongIterator longiterator = this.field_219261_o.iterator();
+      // Spigot start
+      org.spigotmc.SlackActivityAccountant activityAccountant = this.field_219255_i.func_73046_m().slackActivityAccountant;
+      activityAccountant.startActivity(0.5);
+      int targetSize = Math.min(this.field_223181_A.size() - 100,  (int) (this.field_223181_A.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
+      // Spigot end
 
-      for(int i = 0; longiterator.hasNext() && (p_223155_1_.getAsBoolean() || i < 200 || this.field_219261_o.size() > 2000); longiterator.remove()) {
+      while (longiterator.hasNext()) { // Spigot
          long j = longiterator.nextLong();
-         ChunkHolder chunkholder = this.field_219251_e.remove(j);
+         longiterator.remove(); // Spigot
+         ChunkHolder chunkholder = this.updatingChunks.queueRemove(j); // Tuinity - Don't copy
          if (chunkholder != null) {
             this.field_219253_g.put(j, chunkholder);
             this.field_219262_p = true;
-            ++i;
             this.func_219212_a(j, chunkholder);
+            if (!p_223155_1_.getAsBoolean() && this.field_223181_A.size() <= targetSize && activityAccountant.activityTimeIsExhausted()) {
+               break;
+            }
          }
       }
+      activityAccountant.endActivity(); // Spigot
 
       Runnable runnable;
-      while((p_223155_1_.getAsBoolean() || this.field_223181_A.size() > 2000) && (runnable = this.field_223181_A.poll()) != null) {
+
+      int queueTarget = Math.min(this.field_223181_A.size() - 100, (int) (this.field_223181_A.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Target this queue as well
+      while ((p_223155_1_.getAsBoolean() || this.field_223181_A.size() > queueTarget) && (runnable = (Runnable)this.field_223181_A.poll()) != null) { // Paper - Target this queue as well
          runnable.run();
       }
-
-   }
-
+   }
+
+   // Paper start - async chunk save for unload
+   // Note: This is very unsafe to call if the chunk is still in use.
+   // This is also modeled after PlayerChunkMap#saveChunk(IChunkAccess, boolean), with the intentional difference being
+   // serializing the chunk is left to a worker thread.
+   private void asyncSave(IChunk chunk) {
+      ChunkPos chunkPos = chunk.func_76632_l();
+      CompoundNBT poiData = this.func_219189_h().getData(chunk.func_76632_l());
+
+
+      com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.field_219255_i, chunkPos.field_77276_a, chunkPos.field_77275_b,
+              poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - use normal priority
+
+      if (!chunk.func_201593_f()) {
+         return;
+      }
+
+      ChunkStatus chunkstatus = chunk.func_201589_g();
+
+      // Copied from PlayerChunkMap#saveChunk(IChunkAccess, boolean)
+      if (chunkstatus.func_202129_d() != ChunkStatus.Type.LEVELCHUNK) {
+            // Paper start - Optimize save by using status cache
+            try {
+               ChunkStatus statusOnDisk = this.getChunkStatusOnDisk(chunkPos);
+               if (statusOnDisk != null && statusOnDisk.func_202129_d() == ChunkStatus.Type.LEVELCHUNK) {
+                  // Paper end
+                  return;
+               }
+
+               if (chunkstatus == ChunkStatus.field_223226_a_ && chunk.func_201609_c().values().stream().noneMatch(StructureStart::func_75069_d)) {
+                  return;
+               }
+            } catch (IOException ex) {
+               ex.printStackTrace();
+               return;
+            }
+      }
+
+      ChunkSerializer.AsyncSaveData asyncSaveData = ChunkSerializer.getAsyncSaveData(this.field_219255_i, chunk);
+
+      this.field_219255_i.asyncChunkTaskManager.scheduleChunkSave(chunkPos.field_77276_a, chunkPos.field_77275_b, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, // Tuinity - use normal priority
+              asyncSaveData, chunk);
+
+      chunk.func_177432_b(this.field_219255_i.func_82737_E());
+      chunk.func_177427_f(false);
+   }
+   // Paper end
+
+   public CompoundNBT func_227078_e_(ChunkPos chunkcoordintpair) throws IOException {
+      if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+         CompoundNBT ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
+                 .loadChunkDataAsyncFuture(this.field_219255_i, chunkcoordintpair.field_77276_a, chunkcoordintpair.field_77275_b, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
+                         false, true, true).join().chunkData;
+
+         if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
+            throw new IOException("See logs for further detail");
+         }
+         return ret;
+      }
+      return super.func_227078_e_(chunkcoordintpair);
+   }
+
+   @Override
+   public void func_219100_a(ChunkPos chunkcoordintpair, CompoundNBT nbttagcompound) throws IOException {
+      if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
+                 this.field_219255_i, chunkcoordintpair.field_77276_a, chunkcoordintpair.field_77275_b, null, nbttagcompound,
+                 com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - writes are async, no need for priority
+         return;
+      }
+      super.func_219100_a(chunkcoordintpair, nbttagcompound);
+   }
+   // Paper end
+
+   public void updateChunkStatusOnDisk(ChunkPos chunkPos, @Nullable CompoundNBT compound) throws IOException {
+      synchronized (this) {
+         RegionFile regionFile = this.regionFileCache.getRegionFile(chunkPos, false);
+
+         regionFile.setStatus(chunkPos.field_77276_a, chunkPos.field_77275_b, ChunkSerializer.getStatus(compound));
+      }
+   }
+
+   public ChunkStatus getChunkStatusOnDisk(ChunkPos chunkPos) throws IOException {
+      // Paper start - async chunk save for unload
+      IChunk unloadingChunk = this.field_219255_i.asyncChunkTaskManager.getChunkInSaveProgress(chunkPos.field_77276_a, chunkPos.field_77275_b);
+      if (unloadingChunk != null) {
+         return unloadingChunk.func_201589_g();
+      }
+      // Paper end
+      // Paper start - async io
+      CompoundNBT inProgressWrite = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
+              .getPendingWrite(this.field_219255_i, chunkPos.field_77276_a, chunkPos.field_77275_b, false);
+
+      if (inProgressWrite != null) {
+         return ChunkSerializer.getStatus(inProgressWrite);
+      }
+      // Paper end
+      synchronized (this) { // Paper - async io
+         RegionFile regionFile = this.regionFileCache.getRegionFile(chunkPos, true);
+
+         if (regionFile == null || !regionFile.func_222667_d(chunkPos)) {
+            return null;
+         }
+
+         ChunkStatus status = regionFile.getStatusIfCached(chunkPos.field_77276_a, chunkPos.field_77275_b);
+
+         if (status != null) {
+            return status;
+         }
+         // Paper start - async io
+      }
+
+      CompoundNBT compound = this.func_219178_f(chunkPos);
+
+      return ChunkSerializer.getStatus(compound);
+      // Paper end
+   }
+
+   public boolean unloadingPlayerChunk = false; // Tuinity - do not allow ticket level changes while unloading chunks
    private void func_219212_a(long p_219212_1_, ChunkHolder p_219212_3_) {
       CompletableFuture<IChunk> completablefuture = p_219212_3_.func_219302_f();
-      completablefuture.thenAcceptAsync((p_219185_5_) -> {
+      Consumer<IChunk> consumer = (p_219185_5_) -> {
          CompletableFuture<IChunk> completablefuture1 = p_219212_3_.func_219302_f();
          if (completablefuture1 != completablefuture) {
             this.func_219212_a(p_219212_1_, p_219212_3_);
          } else {
-            if (this.field_219253_g.remove(p_219212_1_, p_219212_3_) && p_219185_5_ != null) {
-               if (p_219185_5_ instanceof Chunk) {
-                  ((Chunk)p_219185_5_).func_177417_c(false);
-               }
-
-               this.func_219229_a(p_219185_5_);
-               if (this.field_219254_h.remove(p_219212_1_) && p_219185_5_ instanceof Chunk) {
-                  Chunk chunk = (Chunk)p_219185_5_;
-                  this.field_219255_i.func_217466_a(chunk);
-               }
-
-               this.field_219256_j.func_215581_a(p_219185_5_.func_76632_l());
-               this.field_219256_j.func_215588_z_();
-               this.field_219266_t.func_219508_a(p_219185_5_.func_76632_l(), (ChunkStatus)null);
-            }
-
+            // Tuinity start - do not allow ticket level changes while unloading chunks
+            org.spigotmc.AsyncCatcher.catchOp("playerchunk unload");
+            boolean unloadingBefore = this.unloadingPlayerChunk;
+            this.unloadingPlayerChunk = true;
+            try {
+               // Tuinity end - do not allow ticket level changes while unloading chunks
+               // Tuinity start
+               boolean removed;
+               if (this.field_219253_g.remove(p_219212_1_, p_219212_3_) && p_219185_5_ != null) {
+                  if (p_219185_5_ instanceof Chunk) {
+                     ((Chunk) p_219185_5_).func_177417_c(false);
+                     net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Unload((Chunk) p_219185_5_));
+                  }
+
+                  if (this.field_219254_h.remove(p_219212_1_) && p_219185_5_ instanceof Chunk) {
+                     Chunk chunk = (Chunk) p_219185_5_;
+                     this.field_219255_i.func_217466_a(chunk);
+                  }
+
+                  try {
+                     this.asyncSave(p_219185_5_); // Paper - async chunk saving
+                  } catch (Throwable ex) {
+                     field_219250_d.fatal("Failed to prepare async save, attempting synchronous save", ex);
+                     this.func_219229_a(p_219185_5_);
+                  }
+
+                  this.field_219256_j.func_215581_a(p_219185_5_.func_76632_l());
+                  this.field_219256_j.func_215588_z_();
+                  this.field_219266_t.func_219508_a(p_219185_5_.func_76632_l(), (ChunkStatus) null);
+               }
+
+            } finally { this.unloadingPlayerChunk = unloadingBefore; } // Tuinity - do not allow ticket level changes while unloading chunks
          }
-      }, this.field_223181_A::add).whenComplete((p_223171_1_, p_223171_2_) -> {
+      };
+      completablefuture.thenAcceptAsync(consumer, this.field_223181_A::add).whenComplete((p_223171_1_, p_223171_2_) -> {
          if (p_223171_2_ != null) {
             field_219250_d.error("Failed to save chunk " + p_219212_3_.func_219277_h(), p_223171_2_);
          }
@@ -423,10 +_,16 @@
    }
 
    protected boolean func_219245_b() {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update visibleChunks off of the main thread"); // Tuinity
       if (!this.field_219262_p) {
          return false;
       } else {
-         this.field_219252_f = this.field_219251_e.clone();
+         // Tuinity start - Don't copy
+         synchronized (this.updatingChunks) {
+            this.updatingChunks.performUpdates();
+         }
+         // Tuinity end - Don't copy
+
          this.field_219262_p = false;
          return true;
       }
@@ -464,28 +_,41 @@
                   return this.func_223156_b(p_219244_1_, p_219244_2_);
                }
             }
-         }, this.field_219257_k);
+         }, this.mainInvokingExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainInvokingExecutor); // Paper - optimize chunk status progression without jumping through thread pool - ensure main
       }
    }
 
    private CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> func_223172_f(ChunkPos p_223172_1_) {
-      return CompletableFuture.supplyAsync(() -> {
-         try {
-            this.field_219255_i.func_217381_Z().func_230035_c_("chunkLoad");
-            CompoundNBT compoundnbt = this.func_219178_f(p_223172_1_);
-            if (compoundnbt != null) {
-               boolean flag = compoundnbt.func_150297_b("Level", 10) && compoundnbt.func_74775_l("Level").func_150297_b("Status", 8);
-               if (flag) {
-                  IChunk ichunk = ChunkSerializer.func_222656_a(this.field_219255_i, this.field_219269_w, this.field_219260_n, p_223172_1_, compoundnbt);
-                  ichunk.func_177432_b(this.field_219255_i.func_82737_E());
-                  this.func_241088_a_(p_223172_1_, ichunk.func_201589_g().func_202129_d());
-                  return Either.left(ichunk);
-               }
-
-               field_219250_d.error("Chunk file at {} is missing level data, skipping", (Object)p_223172_1_);
+      // Paper start - Async chunk io
+      final java.util.function.BiFunction<ChunkSerializer.InProgressChunkHolder, Throwable, Either<IChunk, ChunkHolder.IChunkLoadingError>> syncLoadComplete = (chunkHolder, ioThrowable) -> {
+         try { // Paper
+            this.field_219255_i.func_217381_Z().func_76320_a("chunkLoad");
+            // Paper start
+            if (ioThrowable != null) {
+               com.destroystokyo.paper.util.SneakyThrow.sneaky(ioThrowable);
             }
+
+            this.func_219189_h().readColumn(p_223172_1_, chunkHolder.poiData);
+            chunkHolder.tasks.forEach(Runnable::run);
+            //this.getVillagePlace().dequeueUnload(chunkcoordintpair.pair()); // Tuinity
+            // Paper end
+
+            if (chunkHolder.protoChunk != null) {
+
+               if (true) {
+                  ChunkPrimer protochunk = chunkHolder.protoChunk;
+
+                  protochunk.func_177432_b(this.field_219255_i.func_82737_E());
+                  this.func_241088_a_(p_223172_1_, protochunk.func_201589_g().func_202129_d());
+                  return Either.left(protochunk);
+               }
+
+               field_219250_d.error("Chunk file at {} is missing level data, skipping", p_223172_1_);
+
+            } // Paper
          } catch (ReportedException reportedexception) {
             Throwable throwable = reportedexception.getCause();
+
             if (!(throwable instanceof IOException)) {
                this.func_241089_g_(p_223172_1_);
                throw reportedexception;
@@ -498,7 +_,70 @@
 
          this.func_241089_g_(p_223172_1_);
          return Either.left(new ChunkPrimer(p_223172_1_, UpgradeData.field_196994_a));
-      }, this.field_219257_k);
+         // Paper start - Async chunk io
+      };
+      CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> ret = new CompletableFuture<>();
+
+      Consumer<ChunkSerializer.InProgressChunkHolder> chunkHolderConsumer = (ChunkSerializer.InProgressChunkHolder holder) -> {
+         // Go into the chunk load queue and not server task queue so we can be popped out even faster.
+         com.destroystokyo.paper.io.chunk.ChunkTaskManager.queueChunkWaitTask(() -> {
+            try {
+               ret.complete(syncLoadComplete.apply(holder, null));
+            } catch (Exception e) {
+               ret.completeExceptionally(e);
+            }
+         });
+      };
+
+      CompletableFuture<CompoundNBT> chunkSaveFuture = this.field_219255_i.asyncChunkTaskManager.getChunkSaveFuture(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b);
+      ChunkHolder playerChunk = func_219220_a(p_223172_1_.func_201841_a());
+      int chunkPriority = playerChunk != null ? playerChunk.getCurrentPriority() : 33;
+      int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+
+      if (chunkPriority <= 10) {
+         priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+      } else if (chunkPriority <= 20) {
+         priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+      }
+      boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+      if (chunkSaveFuture != null) {
+         this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture);
+      } else {
+         this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority, chunkHolderConsumer, isHighestPriority);
+      }
+      this.field_219255_i.asyncChunkTaskManager.raisePriority(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority);
+      return ret;
+      // Paper end
+//      return CompletableFuture.supplyAsync(() -> {
+//         try {
+//            this.level.getProfiler().incrementCounter("chunkLoad");
+//            CompoundNBT compoundnbt = this.readChunk(p_223172_1_);
+//            if (compoundnbt != null) {
+//               boolean flag = compoundnbt.contains("Level", 10) && compoundnbt.getCompound("Level").contains("Status", 8);
+//               if (flag) {
+//                  IChunk ichunk = ChunkSerializer.read(this.level, this.structureManager, this.poiManager, p_223172_1_, compoundnbt);
+//                  ichunk.setLastSaveTime(this.level.getGameTime());
+//                  this.markPosition(p_223172_1_, ichunk.getStatus().getChunkType());
+//                  return Either.left(ichunk);
+//               }
+//
+//               LOGGER.error("Chunk file at {} is missing level data, skipping", (Object)p_223172_1_);
+//            }
+//         } catch (ReportedException reportedexception) {
+//            Throwable throwable = reportedexception.getCause();
+//            if (!(throwable instanceof IOException)) {
+//               this.markPositionReplaceable(p_223172_1_);
+//               throw reportedexception;
+//            }
+//
+//            LOGGER.error("Couldn't load chunk {}", p_223172_1_, throwable);
+//         } catch (Exception exception) {
+//            LOGGER.error("Couldn't load chunk {}", p_223172_1_, exception);
+//         }
+//
+//         this.markPositionReplaceable(p_223172_1_);
+//         return Either.left(new ChunkPrimer(p_223172_1_, UpgradeData.EMPTY));
+//      }, this.mainThreadExecutor);
    }
 
    private void func_241089_g_(ChunkPos p_241089_1_) {
@@ -538,8 +_,17 @@
             return CompletableFuture.completedFuture(Either.right(p_219211_2_));
          });
       }, (p_219216_2_) -> {
+         // Paper start - optimize chunk status progression without jumping through thread pool
+         if (p_223156_1_.canAdvanceStatus()) {
+            this.mainInvokingExecutor.execute(p_219216_2_);
+            return;
+         }
+         // Paper end
          this.field_219264_r.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219081_a(p_223156_1_, p_219216_2_));
-      });
+      }).thenComposeAsync((either) -> { // Tuinity start - force competion on the main thread
+         return CompletableFuture.completedFuture(either);
+      }, this.mainInvokingExecutor);
+      // Tuinity end - force competion on the main thread
    }
 
    protected void func_219209_c(ChunkPos p_219209_1_) {
@@ -601,12 +_,13 @@
                if (list != null) {
                   list.forEach(chunk::func_76622_b);
                }
+               net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Load(chunk));
             }
 
             return chunk;
          });
       }, (p_219228_2_) -> {
-         this.field_219265_s.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(p_219228_2_, p_219200_1_.func_219277_h().func_201841_a(), p_219200_1_::func_219299_i));
+         this.field_219265_s.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(p_219228_2_, p_219200_1_.func_219277_h().func_201841_a(), () -> 1)); // Paper - final loads are always urgent!
       });
    }
 
@@ -622,15 +_,15 @@
             return Either.left(chunk);
          });
       }, (p_219230_2_) -> {
-         this.field_219265_s.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219081_a(p_219179_1_, p_219230_2_));
+         this.field_219265_s.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219081_a(p_219179_1_, () -> this.chunkLoadConversionCallbackExecutor.execute(p_219230_2_)));  // Paper - delay running Chunk post processing until outside of the sorter to prevent a deadlock scenario when post processing causes another chunk request.
       });
       completablefuture1.thenAcceptAsync((p_219176_2_) -> {
          p_219176_2_.mapLeft((p_219196_2_) -> {
             this.field_219268_v.getAndIncrement();
-            IPacket<?>[] ipacket = new IPacket[2];
-            this.func_219097_a(chunkpos, false).forEach((p_219233_3_) -> {
-               this.func_219180_a(p_219233_3_, ipacket, p_219196_2_);
-            });
+//            IPacket<?>[] ipacket = new IPacket[2];
+//            this.getPlayers(chunkpos, false).forEach((p_219233_3_) -> {
+//               this.playerLoadedChunk(p_219233_3_, ipacket, p_219196_2_);
+//            });
             return Either.left(p_219196_2_);
          });
       }, (p_219202_2_) -> {
@@ -646,9 +_,7 @@
             chunk.func_222879_B();
             return chunk;
          });
-      }, (p_222962_2_) -> {
-         this.field_219265_s.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219081_a(p_222961_1_, p_222962_2_));
-      });
+      }, field_219257_k);  // Tuinity - queue to execute immediately so this doesn't delay chunk unloading
    }
 
    public int func_219174_c() {
@@ -678,7 +_,12 @@
 
             this.field_219255_i.func_217381_Z().func_230035_c_("chunkSave");
             CompoundNBT compoundnbt = ChunkSerializer.func_222645_a(this.field_219255_i, p_219229_1_);
-            this.func_219100_a(chunkpos, compoundnbt);
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Save(p_219229_1_, p_219229_1_.getWorldForge() != null ? p_219229_1_.getWorldForge() : this.field_219255_i, compoundnbt));
+            //this.write(chunkpos, compoundnbt);
+            // Paper start - async chunk io
+            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.field_219255_i, chunkpos.field_77276_a, chunkpos.field_77275_b,
+                    null, compoundnbt, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+            // Paper end - async chunk io
             this.func_241088_a_(chunkpos, chunkstatus.func_202129_d());
             return true;
          } catch (Exception exception) {
@@ -712,32 +_,33 @@
    }
 
    protected void func_219175_a(int p_219175_1_) {
-      int i = MathHelper.func_76125_a(p_219175_1_ + 1, 3, 33);
-      if (i != this.field_219247_A) {
-         int j = this.field_219247_A;
-         this.field_219247_A = i;
-         this.field_219267_u.func_219354_b(this.field_219247_A);
-
-         for(ChunkHolder chunkholder : this.field_219251_e.values()) {
-            ChunkPos chunkpos = chunkholder.func_219277_h();
-            IPacket<?>[] ipacket = new IPacket[2];
-            this.func_219097_a(chunkpos, false).forEach((p_219224_4_) -> {
-               int k = func_219215_b(chunkpos, p_219224_4_, true);
-               boolean flag = k <= j;
-               boolean flag1 = k <= this.field_219247_A;
-               this.func_219199_a(p_219224_4_, chunkpos, ipacket, flag, flag1);
-            });
-         }
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update view distance off of the main thread"); // Tuinity
+      int j = MathHelper.func_76125_a(p_219175_1_ + 1, 3, 33); // Paper - diff on change, these make the lower view distance limit 2 and the upper 32
+
+      if (j != this.field_219247_A) {
+         int k = this.field_219247_A;
+
+         this.field_219247_A = j;
+         this.playerChunkManager.setTickDistance(MathHelper.func_76125_a(p_219175_1_, 2, 32)); // Tuinity - replace player loader system
       }
 
    }
 
-   protected void func_219199_a(ServerPlayerEntity p_219199_1_, ChunkPos p_219199_2_, IPacket<?>[] p_219199_3_, boolean p_219199_4_, boolean p_219199_5_) {
+   // Paper start - no-tick view distance
+   public final void setNoTickViewDistance(int viewDistance) {
+      com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update view distance off of the main thread"); // Tuinity
+      viewDistance = viewDistance == -1 ? -1 : MathHelper.func_76125_a(viewDistance, 2, 32);
+      this.playerChunkManager.setLoadDistance(viewDistance == -1 ? -1 : viewDistance + 1); // Tuinity - replace player loader system - add 1 here, we need an extra one to send to clients for chunks in this viewDistance to render
+   }
+   // Paper end - no-tick view distance
+
+   public void func_219199_a(ServerPlayerEntity p_219199_1_, ChunkPos p_219199_2_, IPacket<?>[] p_219199_3_, boolean p_219199_4_, boolean p_219199_5_) {
       if (p_219199_1_.field_70170_p == this.field_219255_i) {
+         net.minecraftforge.event.ForgeEventFactory.fireChunkWatch(p_219199_4_, p_219199_5_, p_219199_1_, p_219199_2_, this.field_219255_i);
          if (p_219199_5_ && !p_219199_4_) {
             ChunkHolder chunkholder = this.func_219219_b(p_219199_2_.func_201841_a());
             if (chunkholder != null) {
-               Chunk chunk = chunkholder.func_219298_c();
+               Chunk chunk = chunkholder.getSendingChunk();
                if (chunk != null) {
                   this.func_219180_a(p_219199_1_, p_219199_3_, chunk);
                }
@@ -754,7 +_,7 @@
    }
 
    public int func_219194_d() {
-      return this.field_219252_f.size();
+      return this.updatingChunks.getVisibleMap().size(); // Tuinity - Don't copy
    }
 
    protected ChunkManager.ProxyTicketManager func_219246_e() {
@@ -762,13 +_,13 @@
    }
 
    protected Iterable<ChunkHolder> func_223491_f() {
-      return Iterables.unmodifiableIterable(this.field_219252_f.values());
+      return Iterables.unmodifiableIterable(this.getVisibleChunks().values()); // Paper
    }
 
    void func_225406_a(Writer p_225406_1_) throws IOException {
       CSVWriter csvwriter = CSVWriter.func_225428_a().func_225423_a("x").func_225423_a("z").func_225423_a("level").func_225423_a("in_memory").func_225423_a("status").func_225423_a("full_status").func_225423_a("accessible_ready").func_225423_a("ticking_ready").func_225423_a("entity_ticking_ready").func_225423_a("ticket").func_225423_a("spawning").func_225423_a("entity_count").func_225423_a("block_entity_count").func_225422_a(p_225406_1_);
 
-      for(Entry<ChunkHolder> entry : this.field_219252_f.long2ObjectEntrySet()) {
+      for(Entry<ChunkHolder> entry : this.getVisibleChunks().long2ObjectEntrySet()) { // Paper
          ChunkPos chunkpos = new ChunkPos(entry.getLongKey());
          ChunkHolder chunkholder = entry.getValue();
          Optional<IChunk> optional = Optional.ofNullable(chunkholder.func_219287_e());
@@ -801,8 +_,21 @@
 
    @Nullable
    private CompoundNBT func_219178_f(ChunkPos p_219178_1_) throws IOException {
-      CompoundNBT compoundnbt = this.func_227078_e_(p_219178_1_);
-      return compoundnbt == null ? null : this.func_235968_a_(this.field_219255_i.func_234923_W_(), this.field_219259_m, compoundnbt);
+      CompoundNBT nbttagcompound = this.func_227078_e_(p_219178_1_);
+      // Paper start - Cache chunk status on disk
+      if (nbttagcompound == null) {
+         return null;
+      }
+
+      nbttagcompound = this.func_235968_a_(this.field_219255_i.func_234923_W_(), this.field_219259_m, nbttagcompound);
+      if (nbttagcompound == null) {
+         return null;
+      }
+
+      this.updateChunkStatusOnDisk(p_219178_1_, nbttagcompound);
+
+      return nbttagcompound;
+      // Paper end
    }
 
    boolean func_219243_d(ChunkPos p_219243_1_) {
@@ -812,6 +_,38 @@
       });
    }
 
+   // Paper start - async io
+   // this function will not load chunk data off disk to check for status
+   // ret null for unknown, empty for empty status on disk or absent from disk
+   public ChunkStatus getStatusOnDiskNoLoad(int x, int z) {
+      // Paper start - async chunk save for unload
+      IChunk unloadingChunk = this.field_219255_i.asyncChunkTaskManager.getChunkInSaveProgress(x, z);
+      if (unloadingChunk != null) {
+         return unloadingChunk.func_201589_g();
+      }
+      // Paper end
+      // Paper start - async io
+      CompoundNBT inProgressWrite = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
+              .getPendingWrite(this.field_219255_i, x, z, false);
+
+      if (inProgressWrite != null) {
+         return ChunkSerializer.getStatus(inProgressWrite);
+      }
+      // Paper end
+      // variant of PlayerChunkMap#getChunkStatusOnDisk that does not load data off disk, but loads the region file
+      ChunkPos chunkPos = new ChunkPos(x, z);
+      synchronized (field_219255_i.func_72863_F().field_217237_a) {
+         RegionFile file;
+         try {
+            file = field_219255_i.func_72863_F().field_217237_a.regionFileCache.getRegionFile(chunkPos, false);
+         } catch (IOException ex) {
+            throw new RuntimeException(ex);
+         }
+
+         return !file.func_222667_d(chunkPos) ? ChunkStatus.field_223226_a_ : file.getStatusIfCached(x, z);
+      }
+   }
+
    private boolean func_219187_b(ServerPlayerEntity p_219187_1_) {
       return p_219187_1_.func_175149_v() && !this.field_219255_i.func_82736_K().func_223586_b(GameRules.field_223613_p);
    }
@@ -827,20 +_,22 @@
          if (!flag) {
             this.field_219267_u.func_219341_a(SectionPos.func_218157_a(p_219234_1_), p_219234_1_);
          }
+         this.addPlayerToDistanceMaps(p_219234_1_); // Paper - distance maps
       } else {
          SectionPos sectionpos = p_219234_1_.func_213842_M();
          this.field_219271_y.func_219443_a(sectionpos.func_218155_u().func_201841_a(), p_219234_1_);
          if (!flag1) {
             this.field_219267_u.func_219367_b(sectionpos, p_219234_1_);
          }
+         this.removePlayerFromDistanceMaps(p_219234_1_); // Paper - distance maps
       }
 
-      for(int l = i - this.field_219247_A; l <= i + this.field_219247_A; ++l) {
-         for(int k = j - this.field_219247_A; k <= j + this.field_219247_A; ++k) {
-            ChunkPos chunkpos = new ChunkPos(l, k);
-            this.func_219199_a(p_219234_1_, chunkpos, new IPacket[2], !p_219234_2_, p_219234_2_);
-         }
-      }
+//      for(int l = i - this.viewDistance; l <= i + this.viewDistance; ++l) {
+//         for(int k = j - this.viewDistance; k <= j + this.viewDistance; ++k) {
+//            ChunkPos chunkpos = new ChunkPos(l, k);
+//            this.updateChunkTracking(p_219234_1_, chunkpos, new IPacket[2], !p_219234_2_, p_219234_2_);
+//         }
+//      }
 
    }
 
@@ -852,13 +_,13 @@
    }
 
    public void func_219183_a(ServerPlayerEntity p_219183_1_) {
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.field_219272_z.values()) {
-         if (chunkmanager$entitytracker.field_219403_c == p_219183_1_) {
-            chunkmanager$entitytracker.func_219397_a(this.field_219255_i.func_217369_A());
-         } else {
-            chunkmanager$entitytracker.func_219400_b(p_219183_1_);
-         }
-      }
+//      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entityMap.values()) {
+//         if (chunkmanager$entitytracker.entity == p_219183_1_) {
+//            chunkmanager$entitytracker.updatePlayers(this.level.players());
+//         } else {
+//            chunkmanager$entitytracker.updatePlayer(p_219183_1_);
+//         }
+//      }
 
       int l1 = MathHelper.func_76128_c(p_219183_1_.func_226277_ct_()) >> 4;
       int i2 = MathHelper.func_76128_c(p_219183_1_.func_226281_cx_()) >> 4;
@@ -894,57 +_,62 @@
 
       int k = sectionpos.func_218149_a();
       int l = sectionpos.func_218148_c();
-      if (Math.abs(k - l1) <= this.field_219247_A * 2 && Math.abs(l - i2) <= this.field_219247_A * 2) {
-         int k2 = Math.min(l1, k) - this.field_219247_A;
-         int i3 = Math.min(i2, l) - this.field_219247_A;
-         int j3 = Math.max(l1, k) + this.field_219247_A;
-         int k3 = Math.max(i2, l) + this.field_219247_A;
-
-         for(int l3 = k2; l3 <= j3; ++l3) {
-            for(int k1 = i3; k1 <= k3; ++k1) {
-               ChunkPos chunkpos1 = new ChunkPos(l3, k1);
-               boolean flag5 = func_219232_a(chunkpos1, k, l) <= this.field_219247_A;
-               boolean flag6 = func_219232_a(chunkpos1, l1, i2) <= this.field_219247_A;
-               this.func_219199_a(p_219183_1_, chunkpos1, new IPacket[2], flag5, flag6);
-            }
-         }
-      } else {
-         for(int i1 = k - this.field_219247_A; i1 <= k + this.field_219247_A; ++i1) {
-            for(int j1 = l - this.field_219247_A; j1 <= l + this.field_219247_A; ++j1) {
-               ChunkPos chunkpos = new ChunkPos(i1, j1);
-               boolean flag3 = true;
-               boolean flag4 = false;
-               this.func_219199_a(p_219183_1_, chunkpos, new IPacket[2], true, false);
-            }
-         }
-
-         for(int j2 = l1 - this.field_219247_A; j2 <= l1 + this.field_219247_A; ++j2) {
-            for(int l2 = i2 - this.field_219247_A; l2 <= i2 + this.field_219247_A; ++l2) {
-               ChunkPos chunkpos2 = new ChunkPos(j2, l2);
-               boolean flag7 = false;
-               boolean flag8 = true;
-               this.func_219199_a(p_219183_1_, chunkpos2, new IPacket[2], false, true);
-            }
-         }
-      }
+
+      this.updateMaps(p_219183_1_); // Paper - distance maps
+      this.playerChunkManager.updatePlayer(p_219183_1_); // Tuinity - respond to movement immediately
 
    }
 
    public Stream<ServerPlayerEntity> func_219097_a(ChunkPos p_219097_1_, boolean p_219097_2_) {
-      return this.field_219271_y.func_219444_a(p_219097_1_.func_201841_a()).filter((p_219192_3_) -> {
-         int i = func_219215_b(p_219097_1_, p_219192_3_, true);
-         if (i > this.field_219247_A) {
-            return false;
-         } else {
-            return !p_219097_2_ || i == this.field_219247_A;
-         }
-      });
+      // Paper start - per player view distance
+      // there can be potential desync with player's last mapped section and the view distance map, so use the
+      // view distance map here.
+      com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> inRange = this.playerChunkManager.broadcastMap.getObjectsInRange(p_219097_1_); // Tuinity - replace player chunk loader system
+
+      if (inRange == null) {
+         return Stream.empty();
+      }
+      // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+      List<ServerPlayerEntity> players = new java.util.ArrayList<>();
+      Object[] backingSet = inRange.getBackingSet();
+
+      if (p_219097_2_) { // flag -> border only
+         for (int i = 0, len = backingSet.length; i < len; ++i) {
+            Object temp = backingSet[i];
+            if (!(temp instanceof ServerPlayerEntity)) {
+               continue;
+            }
+            ServerPlayerEntity player = (ServerPlayerEntity)temp;
+            if (!this.playerChunkManager.isChunkSent(player, p_219097_1_.field_77276_a, p_219097_1_.field_77275_b)) continue; // Tuinity - replace player chunk management
+            int viewDistance = this.playerChunkManager.broadcastMap.getLastViewDistance(player); // Tuinity - replace player chunk loader system
+            long lastPosition = this.playerChunkManager.broadcastMap.getLastCoordinate(player); // Tuinity - replace player chunk loader system
+
+            int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - p_219097_1_.field_77276_a);
+            int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - p_219097_1_.field_77275_b);
+            if (Math.max(distX, distZ) == viewDistance) {
+               players.add(player);
+            }
+         }
+      } else {
+         for (int i = 0, len = backingSet.length; i < len; ++i) {
+            Object temp = backingSet[i];
+            if (!(temp instanceof ServerPlayerEntity)) {
+               continue;
+            }
+            ServerPlayerEntity player = (ServerPlayerEntity)temp;
+            if (!this.playerChunkManager.isChunkSent(player, p_219097_1_.field_77276_a, p_219097_1_.field_77275_b)) continue; // Tuinity - replace player chunk management
+            players.add(player);
+         }
+      }
+      return players.stream();
+      // Paper end - per player view distance
    }
 
    protected void func_219210_a(Entity p_219210_1_) {
-      if (!(p_219210_1_ instanceof EnderDragonPartEntity)) {
+      if (!(p_219210_1_ instanceof net.minecraftforge.entity.PartEntity)) {
          EntityType<?> entitytype = p_219210_1_.func_200600_R();
          int i = entitytype.func_233602_m_() * 16;
+         i = org.spigotmc.TrackingRange.getEntityTrackingRange(p_219210_1_, i); // Spigot
          int j = entitytype.func_220332_l();
          if (this.field_219272_z.containsKey(p_219210_1_.func_145782_y())) {
             throw (IllegalStateException)Util.func_229757_c_(new IllegalStateException("Entity is already tracked!"));
@@ -1067,7 +_,7 @@
 
    }
 
-   protected PointOfInterestManager func_219189_h() {
+   public PointOfInterestManager func_219189_h() {
       return this.field_219260_n;
    }
 
@@ -1142,7 +_,7 @@
                if (!flag1) {
                   ChunkPos chunkpos = new ChunkPos(this.field_219403_c.field_70176_ah, this.field_219403_c.field_70164_aj);
                   ChunkHolder chunkholder = ChunkManager.this.func_219219_b(chunkpos.func_201841_a());
-                  if (chunkholder != null && chunkholder.func_219298_c() != null) {
+                  if (chunkholder != null && chunkholder.getSendingChunk() != null  && ChunkManager.this.playerChunkManager.isChunkSent(p_219400_1_, MathHelper.func_76128_c(this.field_219403_c.func_226277_ct_()) >> 4, MathHelper.func_76128_c(this.field_219403_c.func_226281_cx_()) >> 4)) {
                      flag1 = ChunkManager.func_219215_b(chunkpos, p_219400_1_, false) <= ChunkManager.this.field_219247_A;
                   }
                }
@@ -1167,6 +_,7 @@
 
          for(Entity entity : collection) {
             int j = entity.func_200600_R().func_233602_m_() * 16;
+            j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
             if (j > i) {
                i = j;
             }
@@ -1183,7 +_,7 @@
       }
    }
 
-   class ProxyTicketManager extends TicketManager {
+   public class ProxyTicketManager extends TicketManager {
       protected ProxyTicketManager(Executor p_i50469_2_, Executor p_i50469_3_) {
          super(p_i50469_2_, p_i50469_3_);
       }
