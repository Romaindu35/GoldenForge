--- a/net/minecraft/world/server/ChunkManager.java
+++ b/net/minecraft/world/server/ChunkManager.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.server;
 
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -49,12 +_,11 @@
 import net.minecraft.nbt.CompoundNBT;
 import net.minecraft.network.DebugPacketSender;
 import net.minecraft.network.IPacket;
-import net.minecraft.network.play.server.SChunkDataPacket;
-import net.minecraft.network.play.server.SMountEntityPacket;
-import net.minecraft.network.play.server.SSetPassengersPacket;
-import net.minecraft.network.play.server.SUpdateChunkPositionPacket;
-import net.minecraft.network.play.server.SUpdateLightPacket;
+import net.minecraft.network.play.ServerPlayNetHandler;
+import net.minecraft.network.play.client.CMoveVehiclePacket;
+import net.minecraft.network.play.server.*;
 import net.minecraft.profiler.IProfiler;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.CSVWriter;
 import net.minecraft.util.ClassInheritanceMultiMap;
 import net.minecraft.util.Util;
@@ -91,6 +_,7 @@
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProvider {
    private static final Logger field_219250_d = LogManager.getLogger();
@@ -99,9 +_,10 @@
    private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219252_f = this.field_219251_e.clone();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219253_g = new Long2ObjectLinkedOpenHashMap<>();
    private final LongSet field_219254_h = new LongOpenHashSet();
-   private final ServerWorld field_219255_i;
+   public final ServerWorld field_219255_i;
    private final ServerWorldLightManager field_219256_j;
    private final ThreadTaskExecutor<Runnable> field_219257_k;
+   public final java.util.concurrent.Executor mainInvokingExecutor; // Paper
    private final ChunkGenerator field_219258_l;
    private final Supplier<DimensionSavedDataManager> field_219259_m;
    private final PointOfInterestManager field_219260_n;
@@ -109,7 +_,7 @@
    private boolean field_219262_p;
    private final ChunkTaskPriorityQueueSorter field_219263_q;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219264_r;
-   private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219265_s;
+   public final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219265_s;
    private final IChunkStatusListener field_219266_t;
    private final ChunkManager.ProxyTicketManager field_219267_u;
    private final AtomicInteger field_219268_v = new AtomicInteger();
@@ -121,6 +_,160 @@
    private final Queue<Runnable> field_223181_A = Queues.newConcurrentLinkedQueue();
    private int field_219247_A;
 
+   // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
+   public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+   public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
+
+      // Paper start - replace impl with recursive safe multi entry queue
+      // it's possible to schedule multiple tasks currently, so it's vital we change this impl
+      // If we recurse into the executor again, we will append to another queue, ensuring task order consistency
+      private java.util.ArrayDeque<Runnable> queued = new java.util.ArrayDeque<>();
+
+      @Override
+      public void execute(Runnable runnable) {
+         AsyncCatcher.catchOp("Callback Executor execute");
+         if (queued == null) {
+            queued = new java.util.ArrayDeque<>();
+         }
+         queued.add(runnable);
+      }
+
+      @Override
+      public void run() {
+         AsyncCatcher.catchOp("Callback Executor run");
+         if (queued == null) {
+            return;
+         }
+         java.util.ArrayDeque<Runnable> queue = queued;
+         queued = null;
+         Runnable task;
+         while ((task = queue.pollFirst()) != null) {
+            task.run();
+         }
+      }
+      // Paper end
+   };
+   // CraftBukkit end
+
+   final CallbackExecutor chunkLoadConversionCallbackExecutor = new CallbackExecutor(); // Paper
+
+   // Paper start - optimise ChunkManager#isOutsideRange
+   private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<ServerPlayerEntity> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+   // A note about the naming used here:
+   // Previously, mojang used a "spawn range" of 8 for controlling both ticking and
+   // mob spawn range. However, spigot makes the spawn range configurable by
+   // checking if the chunk is in the tick range (8) and the spawn range
+   // obviously this means a spawn range > 8 cannot be implemented
+
+   // these maps are named after spigot's uses
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap; // this map is absent from updateMaps since it's controlled at the start of the chunkproviderserver tick
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
+   // Paper end - optimise ChunkManager#isOutsideRange
+   // Paper start - no-tick view distance
+   int noTickViewDistance;
+   public final int getRawNoTickViewDistance() {
+      return this.noTickViewDistance;
+   }
+   public final int getEffectiveNoTickViewDistance() {
+      return this.noTickViewDistance == -1 ? this.getEffectiveViewDistance() : this.noTickViewDistance;
+   }
+   public final int getLoadViewDistance() {
+      return Math.max(this.getEffectiveViewDistance(), this.getEffectiveNoTickViewDistance());
+   }
+
+   public final int getEffectiveViewDistance() {
+      // TODO this needs to be checked on update
+      // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
+      return this.field_219247_A - 1;
+   }
+
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceBroadcastMap;
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceTickMap;
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceNoTickMap;
+   // Paper end - no-tick view distance
+
+   static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
+   public final com.destroystokyo.paper.util.misc.PlayerAreaMap[] playerEntityTrackerTrackMaps;
+   final int[] entityTrackerTrackRanges;
+
+   void addPlayerToDistanceMaps(ServerPlayerEntity player) {
+      int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+      int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+      // Note: players need to be explicitly added to distance maps before they can be updated
+      // Paper start - use distance map to optimise entity tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+         int trackRange = this.entityTrackerTrackRanges[i];
+
+         trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+      }
+      // Paper end - use distance map to optimise entity tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerChunkTickRangeMap.add(player, chunkX, chunkZ, TicketManager.MOB_SPAWN_RANGE);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      int effectiveTickViewDistance = this.getEffectiveViewDistance();
+      int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+      if (!this.func_219187_b(player)) {
+         this.playerViewDistanceTickMap.add(player, chunkX, chunkZ, effectiveTickViewDistance);
+         this.playerViewDistanceNoTickMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+      }
+
+      player.needsChunkCenterUpdate = true;
+      this.playerViewDistanceBroadcastMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+      player.needsChunkCenterUpdate = false;
+      // Paper end - no-tick view distance
+   }
+
+   void removePlayerFromDistanceMaps(ServerPlayerEntity player) {
+      // Paper start - use distance map to optimise tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         this.playerEntityTrackerTrackMaps[i].remove(player);
+      }
+      // Paper end - use distance map to optimise tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerMobSpawnMap.remove(player);
+      this.playerChunkTickRangeMap.remove(player);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      this.playerViewDistanceBroadcastMap.remove(player);
+      this.playerViewDistanceTickMap.remove(player);
+      this.playerViewDistanceNoTickMap.remove(player);
+      // Paper end - no-tick view distance
+   }
+
+   void updateMaps(ServerPlayerEntity player) {
+      int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+      int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+      // Note: players need to be explicitly added to distance maps before they can be updated
+      // Paper start - use distance map to optimise entity tracker
+      for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+         com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+         int trackRange = this.entityTrackerTrackRanges[i];
+
+         trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+      }
+      // Paper end - use distance map to optimise entity tracker
+      // Paper start - optimise PlayerChunkMap#isOutsideRange
+      this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, TicketManager.MOB_SPAWN_RANGE);
+      // Paper end - optimise PlayerChunkMap#isOutsideRange
+      // Paper start - no-tick view distance
+      int effectiveTickViewDistance = this.getEffectiveViewDistance();
+      int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+      if (!this.func_219187_b(player)) {
+         this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveTickViewDistance);
+         this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk 1 neighbour, and we need another 1 for sending those extra neighbours (as we require neighbours to send)
+      }
+
+      player.needsChunkCenterUpdate = true;
+      this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need an extra neighbour to render the full view distance configured
+      player.needsChunkCenterUpdate = false;
+      // Paper end - no-tick view distance
+   }
+   // Paper end
+
    public ChunkManager(ServerWorld p_i232602_1_, SaveFormat.LevelSave p_i232602_2_, DataFixer p_i232602_3_, TemplateManager p_i232602_4_, Executor p_i232602_5_, ThreadTaskExecutor<Runnable> p_i232602_6_, IChunkLightProvider p_i232602_7_, ChunkGenerator p_i232602_8_, IChunkStatusListener p_i232602_9_, Supplier<DimensionSavedDataManager> p_i232602_10_, int p_i232602_11_, boolean p_i232602_12_) {
       super(new File(p_i232602_2_.func_237291_a_(p_i232602_1_.func_234923_W_()), "region"), p_i232602_3_, p_i232602_12_);
       this.field_219269_w = p_i232602_4_;
@@ -128,6 +_,15 @@
       this.field_219255_i = p_i232602_1_;
       this.field_219258_l = p_i232602_8_;
       this.field_219257_k = p_i232602_6_;
+      // Paper start
+      this.mainInvokingExecutor = (run) -> {
+         if (MCUtil.isMainThread()) {
+            run.run();
+         } else {
+            p_i232602_6_.execute(run);
+         }
+      };
+      // Paper end
       DelegatedTaskExecutor<Runnable> delegatedtaskexecutor = DelegatedTaskExecutor.func_213144_a(p_i232602_5_, "worldgen");
       ITaskExecutor<Runnable> itaskexecutor = ITaskExecutor.func_213140_a("main", p_i232602_6_::func_212871_a_);
       this.field_219266_t = p_i232602_9_;
@@ -136,10 +_,127 @@
       this.field_219264_r = this.field_219263_q.func_219087_a(delegatedtaskexecutor, false);
       this.field_219265_s = this.field_219263_q.func_219087_a(itaskexecutor, false);
       this.field_219256_j = new ServerWorldLightManager(p_i232602_7_, this, this.field_219255_i.func_230315_m_().func_218272_d(), delegatedtaskexecutor1, this.field_219263_q.func_219087_a(delegatedtaskexecutor1, false));
-      this.field_219267_u = new ChunkManager.ProxyTicketManager(p_i232602_5_, p_i232602_6_);
+      this.field_219267_u = new ChunkManager.ProxyTicketManager(p_i232602_5_, p_i232602_6_); this.field_219267_u.chunkMap = this; // Paper
       this.field_219259_m = p_i232602_10_;
       this.field_219260_n = new PointOfInterestManager(new File(this.field_219270_x, "poi"), p_i232602_3_, p_i232602_12_);
       this.func_219175_a(p_i232602_11_);
+
+      // Paper start - use distance map to optimise entity tracker
+      this.playerEntityTrackerTrackMaps = new com.destroystokyo.paper.util.misc.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+      this.entityTrackerTrackRanges = new int[TRACKING_RANGE_TYPES.length];
+
+      org.spigotmc.SpigotWorldConfig spigotWorldConfig = this.field_219255_i.spigotConfig;
+
+      for (int ordinal = 0, len = TRACKING_RANGE_TYPES.length; ordinal < len; ++ordinal) {
+         org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = TRACKING_RANGE_TYPES[ordinal];
+         int configuredSpigotValue;
+         switch (trackingRangeType) {
+            case PLAYER:
+               configuredSpigotValue = spigotWorldConfig.playerTrackingRange;
+               break;
+            case ANIMAL:
+               configuredSpigotValue = spigotWorldConfig.animalTrackingRange;
+               break;
+            case MONSTER:
+               configuredSpigotValue = spigotWorldConfig.monsterTrackingRange;
+               break;
+            case MISC:
+               configuredSpigotValue = spigotWorldConfig.miscTrackingRange;
+               break;
+            case OTHER:
+               configuredSpigotValue = spigotWorldConfig.otherTrackingRange;
+               break;
+            case ENDERDRAGON:
+               configuredSpigotValue = EntityType.field_200802_p.defaultTrackingRangeSupplier() * 16;
+               break;
+            default:
+               throw new IllegalStateException("Missing case for enum " + trackingRangeType);
+         }
+         configuredSpigotValue = MinecraftServer.getServer().func_230512_b_(configuredSpigotValue);
+
+         int trackRange = (configuredSpigotValue >>> 4) + ((configuredSpigotValue & 15) != 0 ? 1 : 0);
+         this.entityTrackerTrackRanges[ordinal] = trackRange;
+
+         this.playerEntityTrackerTrackMaps[ordinal] = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+      }
+      // Paper end - use distance map to optimise entity tracker
+
+      // Paper start - optimise ChunkManager#isOutsideRange
+      this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                 }
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                 }
+              });
+      this.playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                 }
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkHolder playerChunk = ChunkManager.this.func_219220_a(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                 if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                 }
+              });
+      // Paper end - optimise ChunkManager#isOutsideRange
+      // Paper start - no-tick view distance
+      this.setNoTickViewDistance(this.field_219255_i.paperConfig.noTickViewDistance);
+      this.playerViewDistanceTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 //checkHighPriorityChunks(player);
+                 if (newState.size() != 1) {
+                    return;
+                 }
+                 Chunk chunk = ChunkManager.this.field_219255_i.func_72863_F().getChunkAtIfLoadedMainThreadNoCache(rangeX, rangeZ);
+                 if (chunk == null || !chunk.areNeighboursLoaded(2)) {
+                    return;
+                 }
+
+                 ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                 ChunkManager.this.field_219255_i.func_72863_F().registerTickingTicket(TicketType.field_219490_c, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 if (newState != null) {
+                    return;
+                 }
+                 ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
+                 ChunkManager.this.field_219255_i.func_72863_F().releaseTickingTicket(TicketType.field_219490_c, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+                 ChunkManager.this.field_219255_i.func_72863_F().clearPriorityTickets(chunkPos);
+              }, (player, prevPos, newPos) -> {
+         //player.lastHighPriorityChecked = -1; // reset and recheck
+         //checkHighPriorityChunks(player);
+      });
+      this.playerViewDistanceNoTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+      this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 if (player.needsChunkCenterUpdate) {
+                    player.needsChunkCenterUpdate = false;
+                    player.field_71135_a.func_147359_a(new SUpdateChunkPositionPacket(currPosX, currPosZ));
+                 }
+                 ChunkManager.this.func_219199_a(player, new ChunkPos(rangeX, rangeZ), new IPacket[2], false, true); // unloaded, loaded
+              },
+              (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+               com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                 ChunkManager.this.func_219199_a(player, new ChunkPos(rangeX, rangeZ), null, true, false); // unloaded, loaded
+              });
+      // Paper end - no-tick view distance
    }
 
    private static double func_219217_a(ChunkPos p_219217_0_, Entity p_219217_1_) {
@@ -176,7 +_,7 @@
    }
 
    @Nullable
-   protected ChunkHolder func_219220_a(long p_219220_1_) {
+   public ChunkHolder func_219220_a(long p_219220_1_) {
       return this.field_219251_e.get(p_219220_1_);
    }
 
@@ -400,6 +_,7 @@
             if (this.field_219253_g.remove(p_219212_1_, p_219212_3_) && p_219185_5_ != null) {
                if (p_219185_5_ instanceof Chunk) {
                   ((Chunk)p_219185_5_).func_177417_c(false);
+                  net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Unload((Chunk)p_219185_5_));
                }
 
                this.func_219229_a(p_219185_5_);
@@ -601,6 +_,7 @@
                if (list != null) {
                   list.forEach(chunk::func_76622_b);
                }
+               net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Load(chunk));
             }
 
             return chunk;
@@ -678,6 +_,7 @@
 
             this.field_219255_i.func_217381_Z().func_230035_c_("chunkSave");
             CompoundNBT compoundnbt = ChunkSerializer.func_222645_a(this.field_219255_i, p_219229_1_);
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Save(p_219229_1_, p_219229_1_.getWorldForge() != null ? p_219229_1_.getWorldForge() : this.field_219255_i, compoundnbt));
             this.func_219100_a(chunkpos, compoundnbt);
             this.func_241088_a_(chunkpos, chunkstatus.func_202129_d());
             return true;
@@ -712,32 +_,62 @@
    }
 
    protected void func_219175_a(int p_219175_1_) {
-      int i = MathHelper.func_76125_a(p_219175_1_ + 1, 3, 33);
-      if (i != this.field_219247_A) {
-         int j = this.field_219247_A;
-         this.field_219247_A = i;
-         this.field_219267_u.func_219354_b(this.field_219247_A);
-
-         for(ChunkHolder chunkholder : this.field_219251_e.values()) {
-            ChunkPos chunkpos = chunkholder.func_219277_h();
-            IPacket<?>[] ipacket = new IPacket[2];
-            this.func_219097_a(chunkpos, false).forEach((p_219224_4_) -> {
-               int k = func_219215_b(chunkpos, p_219224_4_, true);
-               boolean flag = k <= j;
-               boolean flag1 = k <= this.field_219247_A;
-               this.func_219199_a(p_219224_4_, chunkpos, ipacket, flag, flag1);
-            });
+      int j = MathHelper.func_76125_a(p_219175_1_ + 1, 3, 33); // Paper - diff on change, these make the lower view distance limit 2 and the upper 32
+
+      if (j != this.field_219247_A) {
+         int k = this.field_219247_A;
+
+         this.field_219247_A = j;
+         this.setNoTickViewDistance(this.getRawNoTickViewDistance()); //Paper - no-tick view distance - propagate changes to no-tick, which does the actual chunk loading/sending
+      }
+//      int i = MathHelper.clamp(p_219175_1_ + 1, 3, 33);
+//      if (i != this.viewDistance) {
+//         int j = this.viewDistance;
+//         this.viewDistance = i;
+//         this.distanceManager.updatePlayerTickets(this.viewDistance);
+//
+//         for(ChunkHolder chunkholder : this.updatingChunkMap.values()) {
+//            ChunkPos chunkpos = chunkholder.getPos();
+//            IPacket<?>[] ipacket = new IPacket[2];
+//            this.getPlayers(chunkpos, false).forEach((p_219224_4_) -> {
+//               int k = checkerboardDistance(chunkpos, p_219224_4_, true);
+//               boolean flag = k <= j;
+//               boolean flag1 = k <= this.viewDistance;
+//               this.updateChunkTracking(p_219224_4_, chunkpos, ipacket, flag, flag1);
+//            });
+//         }
+//      }
+
+   }
+
+   // Paper start - no-tick view distance
+   public final void setNoTickViewDistance(int viewDistance) {
+      viewDistance = viewDistance == -1 ? -1 : MathHelper.func_76125_a(viewDistance, 2, 32);
+
+      this.noTickViewDistance = viewDistance;
+      int loadViewDistance = this.getLoadViewDistance();
+      this.field_219267_u.setNoTickViewDistance(loadViewDistance + 2 + 2); // add 2 to account for the change to 31 -> 33 tickets // see notes in the distance map updating for the other + 2
+
+      if (this.field_219255_i != null && this.field_219255_i.field_217491_A != null) { // this can be called from constructor, where these aren't set
+         for (ServerPlayerEntity player : this.field_219255_i.field_217491_A) {
+            ServerPlayNetHandler connection = player.field_71135_a;
+            if (connection != null) {
+               // moved in from PlayerList
+               connection.func_147359_a(new SUpdateViewDistancePacket(loadViewDistance));
+            }
+            this.updateMaps(player);
          }
       }
-
    }
+   // Paper end - no-tick view distance
 
    protected void func_219199_a(ServerPlayerEntity p_219199_1_, ChunkPos p_219199_2_, IPacket<?>[] p_219199_3_, boolean p_219199_4_, boolean p_219199_5_) {
       if (p_219199_1_.field_70170_p == this.field_219255_i) {
+         net.minecraftforge.event.ForgeEventFactory.fireChunkWatch(p_219199_4_, p_219199_5_, p_219199_1_, p_219199_2_, this.field_219255_i);
          if (p_219199_5_ && !p_219199_4_) {
             ChunkHolder chunkholder = this.func_219219_b(p_219199_2_.func_201841_a());
             if (chunkholder != null) {
-               Chunk chunk = chunkholder.func_219298_c();
+               Chunk chunk = chunkholder.getSendingChunk(); // Paper - no-tick view distance
                if (chunk != null) {
                   this.func_219180_a(p_219199_1_, p_219199_3_, chunk);
                }
@@ -827,20 +_,22 @@
          if (!flag) {
             this.field_219267_u.func_219341_a(SectionPos.func_218157_a(p_219234_1_), p_219234_1_);
          }
+         this.addPlayerToDistanceMaps(p_219234_1_); // Paper - distance maps
       } else {
          SectionPos sectionpos = p_219234_1_.func_213842_M();
          this.field_219271_y.func_219443_a(sectionpos.func_218155_u().func_201841_a(), p_219234_1_);
          if (!flag1) {
             this.field_219267_u.func_219367_b(sectionpos, p_219234_1_);
          }
+         this.removePlayerFromDistanceMaps(p_219234_1_); // Paper - distance maps
       }
 
-      for(int l = i - this.field_219247_A; l <= i + this.field_219247_A; ++l) {
-         for(int k = j - this.field_219247_A; k <= j + this.field_219247_A; ++k) {
-            ChunkPos chunkpos = new ChunkPos(l, k);
-            this.func_219199_a(p_219234_1_, chunkpos, new IPacket[2], !p_219234_2_, p_219234_2_);
-         }
-      }
+//      for(int l = i - this.viewDistance; l <= i + this.viewDistance; ++l) {
+//         for(int k = j - this.viewDistance; k <= j + this.viewDistance; ++k) {
+//            ChunkPos chunkpos = new ChunkPos(l, k);
+//            this.updateChunkTracking(p_219234_1_, chunkpos, new IPacket[2], !p_219234_2_, p_219234_2_);
+//         }
+//      }
 
    }
 
@@ -892,41 +_,43 @@
          }
       }
 
-      int k = sectionpos.func_218149_a();
-      int l = sectionpos.func_218148_c();
-      if (Math.abs(k - l1) <= this.field_219247_A * 2 && Math.abs(l - i2) <= this.field_219247_A * 2) {
-         int k2 = Math.min(l1, k) - this.field_219247_A;
-         int i3 = Math.min(i2, l) - this.field_219247_A;
-         int j3 = Math.max(l1, k) + this.field_219247_A;
-         int k3 = Math.max(i2, l) + this.field_219247_A;
-
-         for(int l3 = k2; l3 <= j3; ++l3) {
-            for(int k1 = i3; k1 <= k3; ++k1) {
-               ChunkPos chunkpos1 = new ChunkPos(l3, k1);
-               boolean flag5 = func_219232_a(chunkpos1, k, l) <= this.field_219247_A;
-               boolean flag6 = func_219232_a(chunkpos1, l1, i2) <= this.field_219247_A;
-               this.func_219199_a(p_219183_1_, chunkpos1, new IPacket[2], flag5, flag6);
-            }
-         }
-      } else {
-         for(int i1 = k - this.field_219247_A; i1 <= k + this.field_219247_A; ++i1) {
-            for(int j1 = l - this.field_219247_A; j1 <= l + this.field_219247_A; ++j1) {
-               ChunkPos chunkpos = new ChunkPos(i1, j1);
-               boolean flag3 = true;
-               boolean flag4 = false;
-               this.func_219199_a(p_219183_1_, chunkpos, new IPacket[2], true, false);
-            }
-         }
-
-         for(int j2 = l1 - this.field_219247_A; j2 <= l1 + this.field_219247_A; ++j2) {
-            for(int l2 = i2 - this.field_219247_A; l2 <= i2 + this.field_219247_A; ++l2) {
-               ChunkPos chunkpos2 = new ChunkPos(j2, l2);
-               boolean flag7 = false;
-               boolean flag8 = true;
-               this.func_219199_a(p_219183_1_, chunkpos2, new IPacket[2], false, true);
-            }
-         }
-      }
+      this.updateMaps(p_219183_1_);
+
+//      int k = sectionpos.x();
+//      int l = sectionpos.z();
+//      if (Math.abs(k - l1) <= this.viewDistance * 2 && Math.abs(l - i2) <= this.viewDistance * 2) {
+//         int k2 = Math.min(l1, k) - this.viewDistance;
+//         int i3 = Math.min(i2, l) - this.viewDistance;
+//         int j3 = Math.max(l1, k) + this.viewDistance;
+//         int k3 = Math.max(i2, l) + this.viewDistance;
+//
+//         for(int l3 = k2; l3 <= j3; ++l3) {
+//            for(int k1 = i3; k1 <= k3; ++k1) {
+//               ChunkPos chunkpos1 = new ChunkPos(l3, k1);
+//               boolean flag5 = checkerboardDistance(chunkpos1, k, l) <= this.viewDistance;
+//               boolean flag6 = checkerboardDistance(chunkpos1, l1, i2) <= this.viewDistance;
+//               this.updateChunkTracking(p_219183_1_, chunkpos1, new IPacket[2], flag5, flag6);
+//            }
+//         }
+//      } else {
+//         for(int i1 = k - this.viewDistance; i1 <= k + this.viewDistance; ++i1) {
+//            for(int j1 = l - this.viewDistance; j1 <= l + this.viewDistance; ++j1) {
+//               ChunkPos chunkpos = new ChunkPos(i1, j1);
+//               boolean flag3 = true;
+//               boolean flag4 = false;
+//               this.updateChunkTracking(p_219183_1_, chunkpos, new IPacket[2], true, false);
+//            }
+//         }
+//
+//         for(int j2 = l1 - this.viewDistance; j2 <= l1 + this.viewDistance; ++j2) {
+//            for(int l2 = i2 - this.viewDistance; l2 <= i2 + this.viewDistance; ++l2) {
+//               ChunkPos chunkpos2 = new ChunkPos(j2, l2);
+//               boolean flag7 = false;
+//               boolean flag8 = true;
+//               this.updateChunkTracking(p_219183_1_, chunkpos2, new IPacket[2], false, true);
+//            }
+//         }
+//      }
 
    }
 
@@ -941,17 +_,30 @@
       });
    }
 
-   protected void func_219210_a(Entity p_219210_1_) {
-      if (!(p_219210_1_ instanceof EnderDragonPartEntity)) {
+   public void func_219210_a(Entity p_219210_1_) {
+      org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
+      // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
+      if (p_219210_1_.field_70170_p != this.field_219255_i || this.field_219272_z.containsKey(p_219210_1_.func_145782_y())) {
+         new Throwable("[ERROR] Illegal PlayerChunkMap::addEntity for world " + this.field_219255_i.func_234923_W_().func_240901_a_()
+                 + ": " + p_219210_1_  + (this.field_219272_z.containsKey(p_219210_1_.func_145782_y()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""))
+                 .printStackTrace();
+         return;
+      }
+      // GoldenForge - not needed
+      //if (p_219210_1_ instanceof ServerPlayerEntity && ((ServerPlayerEntity) p_219210_1_).supressTrackerForLogin) return; // Delay adding to tracker until after list packets
+      // Paper end
+      if (!(p_219210_1_ instanceof net.minecraftforge.entity.PartEntity)) {
          EntityType<?> entitytype = p_219210_1_.func_200600_R();
          int i = entitytype.func_233602_m_() * 16;
+         i = org.spigotmc.TrackingRange.getEntityTrackingRange(p_219210_1_, i); // Spigot
          int j = entitytype.func_220332_l();
          if (this.field_219272_z.containsKey(p_219210_1_.func_145782_y())) {
             throw (IllegalStateException)Util.func_229757_c_(new IllegalStateException("Entity is already tracked!"));
          } else {
             ChunkManager.EntityTracker chunkmanager$entitytracker = new ChunkManager.EntityTracker(p_219210_1_, i, j, entitytype.func_220340_m());
+            p_219210_1_.tracker = chunkmanager$entitytracker; // Paper - Fast access to tracker
             this.field_219272_z.put(p_219210_1_.func_145782_y(), chunkmanager$entitytracker);
-            chunkmanager$entitytracker.func_219397_a(this.field_219255_i.func_217369_A());
+            chunkmanager$entitytracker.updatePlayers(p_219210_1_.getPlayersInTrackRange());
             if (p_219210_1_ instanceof ServerPlayerEntity) {
                ServerPlayerEntity serverplayerentity = (ServerPlayerEntity)p_219210_1_;
                this.func_219234_a(serverplayerentity, true);
@@ -968,6 +_,7 @@
    }
 
    protected void func_219231_b(Entity p_219231_1_) {
+      org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
       if (p_219231_1_ instanceof ServerPlayerEntity) {
          ServerPlayerEntity serverplayerentity = (ServerPlayerEntity)p_219231_1_;
          this.func_219234_a(serverplayerentity, false);
@@ -981,10 +_,41 @@
       if (chunkmanager$entitytracker1 != null) {
          chunkmanager$entitytracker1.func_219396_a();
       }
-
-   }
+      p_219231_1_.tracker = null; // Paper - We're no longer tracked
+
+   }
+
+   // Paper start - optimised tracker
+   private final void processTrackQueue() {
+      //this.world.timings.tracker1.startTiming();
+      try {
+         for (EntityTracker tracker : this.field_219272_z.values()) {
+            // update tracker entry
+            tracker.updatePlayers(tracker.field_219403_c.getPlayersInTrackRange());
+         }
+      } finally {
+        //this.world.timings.tracker1.stopTiming();
+      }
+
+
+      //this.world.timings.tracker2.startTiming();
+      try {
+         for (EntityTracker tracker : this.field_219272_z.values()) {
+            tracker.field_219402_b.func_219453_a();
+         }
+      } finally {
+         //this.world.timings.tracker2.stopTiming();
+      }
+   }
+   // Paper end - optimised tracker
 
    protected void func_219169_g() {
+      // Paper start - optimized tracker
+      if (true) {
+         this.processTrackQueue();
+         return;
+      }
+      // Paper end - optimized tracker
       List<ServerPlayerEntity> list = Lists.newArrayList();
       List<ServerPlayerEntity> list1 = this.field_219255_i.func_217369_A();
 
@@ -1028,7 +_,7 @@
 
    }
 
-   private void func_219180_a(ServerPlayerEntity p_219180_1_, IPacket<?>[] p_219180_2_, Chunk p_219180_3_) {
+   public void func_219180_a(ServerPlayerEntity p_219180_1_, IPacket<?>[] p_219180_2_, Chunk p_219180_3_) {
       if (p_219180_2_[0] == null) {
          p_219180_2_[0] = new SChunkDataPacket(p_219180_3_, 65535);
          p_219180_2_[1] = new SUpdateLightPacket(p_219180_3_.func_76632_l(), this.field_219256_j, true);
@@ -1038,20 +_,45 @@
       DebugPacketSender.func_218802_a(this.field_219255_i, p_219180_3_.func_76632_l());
       List<Entity> list = Lists.newArrayList();
       List<Entity> list1 = Lists.newArrayList();
-
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.field_219272_z.values()) {
-         Entity entity = chunkmanager$entitytracker.field_219403_c;
-         if (entity != p_219180_1_ && entity.field_70176_ah == p_219180_3_.func_76632_l().field_77276_a && entity.field_70164_aj == p_219180_3_.func_76632_l().field_77275_b) {
-            chunkmanager$entitytracker.func_219400_b(p_219180_1_);
-            if (entity instanceof MobEntity && ((MobEntity)entity).func_110166_bE() != null) {
-               list.add(entity);
-            }
-
-            if (!entity.func_184188_bt().isEmpty()) {
-               list1.add(entity);
-            }
+      // Paper start - optimise entity tracker
+      // use the chunk entity list, not the whole trackedEntities map...
+      Entity[] entities = p_219180_3_.entities.getRawData();
+      for (int i = 0, size = p_219180_3_.entities.size(); i < size; ++i) {
+         Entity entity = entities[i];
+         if (entity == p_219180_1_) {
+            continue;
+         }
+         ChunkManager.EntityTracker tracker = this.field_219272_z.get(entity.func_145782_y());
+         if (tracker != null) { // dumb plugins... move on...
+            tracker.func_219400_b(p_219180_1_);
+         }
+
+         // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+         // (and god knows what the leash thing is)
+
+         if (entity instanceof MobEntity && ((MobEntity)entity).func_110166_bE() != null) {
+            list.add(entity);
+         }
+
+         if (!entity.field_184244_h.isEmpty()) { // Paper - do not copy list
+            list1.add(entity);
          }
       }
+      // Paper end - optimise entity tracker
+
+//      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entityMap.values()) {
+//         Entity entity = chunkmanager$entitytracker.entity;
+//         if (entity != p_219180_1_ && entity.xChunk == p_219180_3_.getPos().x && entity.zChunk == p_219180_3_.getPos().z) {
+//            chunkmanager$entitytracker.updatePlayer(p_219180_1_);
+//            if (entity instanceof MobEntity && ((MobEntity)entity).getLeashHolder() != null) {
+//               list.add(entity);
+//            }
+//
+//            if (!entity.getPassengers().isEmpty()) {
+//               list1.add(entity);
+//            }
+//         }
+//      }
 
       if (!list.isEmpty()) {
          for(Entity entity1 : list) {
@@ -1077,12 +_,16 @@
       });
    }
 
-   class EntityTracker {
+   public class EntityTracker {
       private final TrackedEntity field_219402_b;
       private final Entity field_219403_c;
       private final int field_219404_d;
       private SectionPos field_219405_e;
-      private final Set<ServerPlayerEntity> field_219406_f = Sets.newHashSet();
+      // Paper start
+      // Replace trackedPlayers Set with a Map. The value is true until the player receives
+      // their first update (which is forced to have absolute coordinates), false afterward.
+      public java.util.Map<ServerPlayerEntity, Boolean> trackedPlayerMap = new java.util.HashMap<>();
+      private final Set<ServerPlayerEntity> field_219406_f = trackedPlayerMap.keySet();
 
       public EntityTracker(Entity p_i50468_2_, int p_i50468_3_, int p_i50468_4_, boolean p_i50468_5_) {
          this.field_219402_b = new TrackedEntity(ChunkManager.this.field_219255_i, p_i50468_2_, p_i50468_4_, p_i50468_5_, this::func_219391_a);
@@ -1091,6 +_,42 @@
          this.field_219405_e = SectionPos.func_218157_a(p_i50468_2_);
       }
 
+      // Paper start - use distance map to optimise tracker
+      com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> lastTrackerCandidates;
+
+      final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newTrackerCandidates) {
+         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> oldTrackerCandidates = this.lastTrackerCandidates;
+         this.lastTrackerCandidates = newTrackerCandidates;
+
+         if (newTrackerCandidates != null) {
+            Object[] rawData = newTrackerCandidates.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+               Object raw = rawData[i];
+               if (!(raw instanceof ServerPlayerEntity)) {
+                  continue;
+               }
+               ServerPlayerEntity player = (ServerPlayerEntity)raw;
+               this.func_219400_b(player);
+            }
+         }
+
+         if (oldTrackerCandidates == newTrackerCandidates) {
+            // this is likely the case.
+            // means there has been no range changes, so we can just use the above for tracking.
+            return;
+         }
+
+         // stuff could have been removed, so we need to check the trackedPlayers set
+         // for players that were removed
+
+         for (ServerPlayerEntity player : this.field_219406_f.toArray(new ServerPlayerEntity[0])) { // avoid CME
+            if (newTrackerCandidates == null || !newTrackerCandidates.contains(player)) {
+               this.func_219400_b(player);
+            }
+         }
+      }
+      // Paper end - use distance map to optimise tracker
+
       public boolean equals(Object p_equals_1_) {
          if (p_equals_1_ instanceof ChunkManager.EntityTracker) {
             return ((ChunkManager.EntityTracker)p_equals_1_).field_219403_c.func_145782_y() == this.field_219403_c.func_145782_y();
@@ -1126,6 +_,7 @@
       }
 
       public void func_219399_a(ServerPlayerEntity p_219399_1_) {
+         org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
          if (this.field_219406_f.remove(p_219399_1_)) {
             this.field_219402_b.func_219454_a(p_219399_1_);
          }
@@ -1133,21 +_,28 @@
       }
 
       public void func_219400_b(ServerPlayerEntity p_219400_1_) {
+         org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
          if (p_219400_1_ != this.field_219403_c) {
-            Vector3d vector3d = p_219400_1_.func_213303_ch().func_178788_d(this.field_219402_b.func_219456_b());
+            //Vector3d vector3d = p_219400_1_.position().subtract(this.serverEntity.sentPos());
+            // Paper start - remove allocation of Vec3D here
+            //Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+            double vec3d_dx = p_219400_1_.func_226277_ct_() - this.field_219403_c.func_226277_ct_();
+            double vec3d_dy = p_219400_1_.func_226278_cu_() - this.field_219403_c.func_226278_cu_();
+            double vec3d_dz = p_219400_1_.func_226281_cx_() - this.field_219403_c.func_226281_cx_();
+            // Paper end - remove allocation of Vec3D here
             int i = Math.min(this.func_229843_b_(), (ChunkManager.this.field_219247_A - 1) * 16);
-            boolean flag = vector3d.field_72450_a >= (double)(-i) && vector3d.field_72450_a <= (double)i && vector3d.field_72449_c >= (double)(-i) && vector3d.field_72449_c <= (double)i && this.field_219403_c.func_174827_a(p_219400_1_);
+            boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double)i && this.field_219403_c.func_174827_a(p_219400_1_);
             if (flag) {
                boolean flag1 = this.field_219403_c.field_98038_p;
                if (!flag1) {
                   ChunkPos chunkpos = new ChunkPos(this.field_219403_c.field_70176_ah, this.field_219403_c.field_70164_aj);
                   ChunkHolder chunkholder = ChunkManager.this.func_219219_b(chunkpos.func_201841_a());
-                  if (chunkholder != null && chunkholder.func_219298_c() != null) {
+                  if (chunkholder != null && chunkholder.getSendingChunk() != null) {
                      flag1 = ChunkManager.func_219215_b(chunkpos, p_219400_1_, false) <= ChunkManager.this.field_219247_A;
                   }
                }
 
-               if (flag1 && this.field_219406_f.add(p_219400_1_)) {
+               if (flag1 && this.trackedPlayerMap.putIfAbsent(p_219400_1_, true) == null) {
                   this.field_219402_b.func_219455_b(p_219400_1_);
                }
             } else if (this.field_219406_f.remove(p_219400_1_)) {
@@ -1167,7 +_,8 @@
 
          for(Entity entity : collection) {
             int j = entity.func_200600_R().func_233602_m_() * 16;
-            if (j > i) {
+            j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
+            if (j < i) { // Paper - we need the lowest range thanks to the fact that our tracker doesn't account for passenger logic
                i = j;
             }
          }
